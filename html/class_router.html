<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Click: Router Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Click
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="class_router-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Router Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A router configuration.  
 <a href="class_router.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a104113a4f08ad5dd5176b969326feb9d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>STOP_RUNCOUNT</b> = -2147483647 - 1
 }</td></tr>
<tr class="separator:a104113a4f08ad5dd5176b969326feb9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4a48384afe47568083f92fd0b9b090"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>FIRST_GLOBAL_HANDLER</b> = 0x40000000
 }</td></tr>
<tr class="separator:a2c4a48384afe47568083f92fd0b9b090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f0e296cf498fe08cb4d91bcf310e44"><td class="memItemLeft" align="right" valign="top">Master *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#ac7f0e296cf498fe08cb4d91bcf310e44">master</a> () const </td></tr>
<tr class="memdesc:ac7f0e296cf498fe08cb4d91bcf310e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Master object for this router.  <a href="#ac7f0e296cf498fe08cb4d91bcf310e44">More...</a><br/></td></tr>
<tr class="separator:ac7f0e296cf498fe08cb4d91bcf310e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b7ee23654ecac1d53ed31bf5ef89e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a96b7ee23654ecac1d53ed31bf5ef89e0">initialized</a> () const </td></tr>
<tr class="memdesc:a96b7ee23654ecac1d53ed31bf5ef89e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff the router has been successfully initialized.  <a href="#a96b7ee23654ecac1d53ed31bf5ef89e0">More...</a><br/></td></tr>
<tr class="separator:a96b7ee23654ecac1d53ed31bf5ef89e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002689f7932e1915559c5a984fe72609"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a002689f7932e1915559c5a984fe72609">handlers_ready</a> () const </td></tr>
<tr class="memdesc:a002689f7932e1915559c5a984fe72609"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff the router's handlers have been initialized.  <a href="#a002689f7932e1915559c5a984fe72609">More...</a><br/></td></tr>
<tr class="separator:a002689f7932e1915559c5a984fe72609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071badc0da30370e78e972e3749bc31a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a071badc0da30370e78e972e3749bc31a">running</a> () const </td></tr>
<tr class="memdesc:a071badc0da30370e78e972e3749bc31a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff the router is currently running.  <a href="#a071badc0da30370e78e972e3749bc31a">More...</a><br/></td></tr>
<tr class="separator:a071badc0da30370e78e972e3749bc31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d64a7777fc6bb4482ae25ccc0725bfb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a0d64a7777fc6bb4482ae25ccc0725bfb">dying</a> () const </td></tr>
<tr class="memdesc:a0d64a7777fc6bb4482ae25ccc0725bfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff the router is in the process of being killed.  <a href="#a0d64a7777fc6bb4482ae25ccc0725bfb">More...</a><br/></td></tr>
<tr class="separator:a0d64a7777fc6bb4482ae25ccc0725bfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdddb3c9cd1ee804773bcb98ba8771fa"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#acdddb3c9cd1ee804773bcb98ba8771fa">runcount</a> () const </td></tr>
<tr class="memdesc:acdddb3c9cd1ee804773bcb98ba8771fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the router's runcount.  <a href="#acdddb3c9cd1ee804773bcb98ba8771fa">More...</a><br/></td></tr>
<tr class="separator:acdddb3c9cd1ee804773bcb98ba8771fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c655b7607d14c1c348a02da235d5bba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a3c655b7607d14c1c348a02da235d5bba">adjust_runcount</a> (int32_t delta)</td></tr>
<tr class="memdesc:a3c655b7607d14c1c348a02da235d5bba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adjust the runcount by <em>delta</em>.  <a href="#a3c655b7607d14c1c348a02da235d5bba">More...</a><br/></td></tr>
<tr class="separator:a3c655b7607d14c1c348a02da235d5bba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d36190f5dd3500d8e9dc591ab03aa33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a3d36190f5dd3500d8e9dc591ab03aa33">set_runcount</a> (int32_t rc)</td></tr>
<tr class="memdesc:a3d36190f5dd3500d8e9dc591ab03aa33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the runcount.  <a href="#a3d36190f5dd3500d8e9dc591ab03aa33">More...</a><br/></td></tr>
<tr class="separator:a3d36190f5dd3500d8e9dc591ab03aa33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47550fb34c0e88beadb5633ba7c69dd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a47550fb34c0e88beadb5633ba7c69dd1">please_stop_driver</a> ()</td></tr>
<tr class="memdesc:a47550fb34c0e88beadb5633ba7c69dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request a driver stop by adjusting the runcount by -1.  <a href="#a47550fb34c0e88beadb5633ba7c69dd1">More...</a><br/></td></tr>
<tr class="separator:a47550fb34c0e88beadb5633ba7c69dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad0fe36c507dbdafec994133f816e75"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_element.html">Element</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a7ad0fe36c507dbdafec994133f816e75">elements</a> () const </td></tr>
<tr class="memdesc:a7ad0fe36c507dbdafec994133f816e75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing all the router's elements.  <a href="#a7ad0fe36c507dbdafec994133f816e75">More...</a><br/></td></tr>
<tr class="separator:a7ad0fe36c507dbdafec994133f816e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc2dc075a870b8d7163f20b3fa05c68a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#adc2dc075a870b8d7163f20b3fa05c68a">nelements</a> () const </td></tr>
<tr class="memdesc:adc2dc075a870b8d7163f20b3fa05c68a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the router.  <a href="#adc2dc075a870b8d7163f20b3fa05c68a">More...</a><br/></td></tr>
<tr class="separator:adc2dc075a870b8d7163f20b3fa05c68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7737aa7500d9be28d537a8aad165b493"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a7737aa7500d9be28d537a8aad165b493">element</a> (int i) const </td></tr>
<tr class="memdesc:a7737aa7500d9be28d537a8aad165b493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the element with index <em>i</em>.  <a href="#a7737aa7500d9be28d537a8aad165b493">More...</a><br/></td></tr>
<tr class="separator:a7737aa7500d9be28d537a8aad165b493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6839bfb0b5a2f27b4b3e41e2fa3fb51c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a6839bfb0b5a2f27b4b3e41e2fa3fb51c">root_element</a> () const </td></tr>
<tr class="memdesc:a6839bfb0b5a2f27b4b3e41e2fa3fb51c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns this router's root element.  <a href="#a6839bfb0b5a2f27b4b3e41e2fa3fb51c">More...</a><br/></td></tr>
<tr class="separator:a6839bfb0b5a2f27b4b3e41e2fa3fb51c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d77740b46817d26e94545a95b4caf70"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a5d77740b46817d26e94545a95b4caf70">ename</a> (int i) const </td></tr>
<tr class="memdesc:a5d77740b46817d26e94545a95b4caf70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns element index <em>eindex's</em> name.  <a href="#a5d77740b46817d26e94545a95b4caf70">More...</a><br/></td></tr>
<tr class="separator:a5d77740b46817d26e94545a95b4caf70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3c308b39e55f460041267dc8ffaed6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a6a3c308b39e55f460041267dc8ffaed6">ename_context</a> (int i) const </td></tr>
<tr class="memdesc:a6a3c308b39e55f460041267dc8ffaed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns element index <em>eindex's</em> name context.  <a href="#a6a3c308b39e55f460041267dc8ffaed6">More...</a><br/></td></tr>
<tr class="separator:a6a3c308b39e55f460041267dc8ffaed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b76acf16b151730739b7fb0ecb30820"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a6b76acf16b151730739b7fb0ecb30820">elandmark</a> (int i) const </td></tr>
<tr class="memdesc:a6b76acf16b151730739b7fb0ecb30820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns element index <em>eindex's</em> landmark.  <a href="#a6b76acf16b151730739b7fb0ecb30820">More...</a><br/></td></tr>
<tr class="separator:a6b76acf16b151730739b7fb0ecb30820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad616383b1878cd5261ec68086720bb73"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#ad616383b1878cd5261ec68086720bb73">econfiguration</a> (int i) const </td></tr>
<tr class="memdesc:ad616383b1878cd5261ec68086720bb73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns element index <em>eindex's</em> configuration string.  <a href="#ad616383b1878cd5261ec68086720bb73">More...</a><br/></td></tr>
<tr class="separator:ad616383b1878cd5261ec68086720bb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403eb46153271a67d3cb78883d74273f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a403eb46153271a67d3cb78883d74273f">set_econfiguration</a> (int i, const <a class="el" href="class_string.html">String</a> &amp;conf)</td></tr>
<tr class="memdesc:a403eb46153271a67d3cb78883d74273f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets element index <em>eindex's</em> configuration string.  <a href="#a403eb46153271a67d3cb78883d74273f">More...</a><br/></td></tr>
<tr class="separator:a403eb46153271a67d3cb78883d74273f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0c4986f3f4763dce781bba80c741c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a3f0c4986f3f4763dce781bba80c741c2">find</a> (const <a class="el" href="class_string.html">String</a> &amp;name, <a class="el" href="class_error_handler.html">ErrorHandler</a> *errh=0) const </td></tr>
<tr class="memdesc:a3f0c4986f3f4763dce781bba80c741c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element named <em>name</em>.  <a href="#a3f0c4986f3f4763dce781bba80c741c2">More...</a><br/></td></tr>
<tr class="separator:a3f0c4986f3f4763dce781bba80c741c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6745f4de754fdffc93d710949bd5a4cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a6745f4de754fdffc93d710949bd5a4cf">find</a> (const <a class="el" href="class_string.html">String</a> &amp;name, <a class="el" href="class_string.html">String</a> context, <a class="el" href="class_error_handler.html">ErrorHandler</a> *errh=0) const </td></tr>
<tr class="memdesc:a6745f4de754fdffc93d710949bd5a4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element named <em>name</em>.  <a href="#a6745f4de754fdffc93d710949bd5a4cf">More...</a><br/></td></tr>
<tr class="separator:a6745f4de754fdffc93d710949bd5a4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a957f736c4de4aa54709cd69020f89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a48a957f736c4de4aa54709cd69020f89">find</a> (const <a class="el" href="class_string.html">String</a> &amp;name, const <a class="el" href="class_element.html">Element</a> *context, <a class="el" href="class_error_handler.html">ErrorHandler</a> *errh=0) const </td></tr>
<tr class="memdesc:a48a957f736c4de4aa54709cd69020f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds an element named <em>name</em>.  <a href="#a48a957f736c4de4aa54709cd69020f89">More...</a><br/></td></tr>
<tr class="separator:a48a957f736c4de4aa54709cd69020f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0583b91f9217950a2059ccb94e7f9d1b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a0583b91f9217950a2059ccb94e7f9d1b">visit</a> (<a class="el" href="class_element.html">Element</a> *e, bool isoutput, int port, <a class="el" href="class_router_visitor.html">RouterVisitor</a> *visitor) const </td></tr>
<tr class="memdesc:a0583b91f9217950a2059ccb94e7f9d1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the router configuration from one of <em>e's</em> ports.  <a href="#a0583b91f9217950a2059ccb94e7f9d1b">More...</a><br/></td></tr>
<tr class="separator:a0583b91f9217950a2059ccb94e7f9d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31864307d3183dc2c705d6b8ccf9dc66"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a31864307d3183dc2c705d6b8ccf9dc66">visit_downstream</a> (<a class="el" href="class_element.html">Element</a> *e, int port, <a class="el" href="class_router_visitor.html">RouterVisitor</a> *visitor) const </td></tr>
<tr class="memdesc:a31864307d3183dc2c705d6b8ccf9dc66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the router configuration downstream of <em>e</em>[<em>port</em>].  <a href="#a31864307d3183dc2c705d6b8ccf9dc66">More...</a><br/></td></tr>
<tr class="separator:a31864307d3183dc2c705d6b8ccf9dc66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab287fdc68a04983b010b879ce4a6a3cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#ab287fdc68a04983b010b879ce4a6a3cb">visit_upstream</a> (<a class="el" href="class_element.html">Element</a> *e, int port, <a class="el" href="class_router_visitor.html">RouterVisitor</a> *visitor) const </td></tr>
<tr class="memdesc:ab287fdc68a04983b010b879ce4a6a3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traverse the router configuration upstream of [<em>port</em>]<em>e</em>.  <a href="#ab287fdc68a04983b010b879ce4a6a3cb">More...</a><br/></td></tr>
<tr class="separator:ab287fdc68a04983b010b879ce4a6a3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefbd96196a5f435296bc2a9a977413ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#aefbd96196a5f435296bc2a9a977413ad">downstream_elements</a> (<a class="el" href="class_element.html">Element</a> *e, int port, <a class="el" href="class_element_filter.html">ElementFilter</a> *filter, <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_element.html">Element</a> * &gt; &amp;result)</td></tr>
<tr class="memdesc:aefbd96196a5f435296bc2a9a977413ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for elements downstream from <em>e</em>.  <a href="#aefbd96196a5f435296bc2a9a977413ad">More...</a><br/></td></tr>
<tr class="separator:aefbd96196a5f435296bc2a9a977413ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64f8eff036d8d8b18ae9aeb2bf63623"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#ad64f8eff036d8d8b18ae9aeb2bf63623">upstream_elements</a> (<a class="el" href="class_element.html">Element</a> *e, int port, <a class="el" href="class_element_filter.html">ElementFilter</a> *filter, <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_element.html">Element</a> * &gt; &amp;result)</td></tr>
<tr class="memdesc:ad64f8eff036d8d8b18ae9aeb2bf63623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for elements upstream from <em>e</em>.  <a href="#ad64f8eff036d8d8b18ae9aeb2bf63623">More...</a><br/></td></tr>
<tr class="separator:ad64f8eff036d8d8b18ae9aeb2bf63623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d7b1d04892b41e393372edc6756266"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a89d7b1d04892b41e393372edc6756266">flow_code_override</a> (int eindex) const </td></tr>
<tr class="memdesc:a89d7b1d04892b41e393372edc6756266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the overriding flow code for element <em>e</em>, if any.  <a href="#a89d7b1d04892b41e393372edc6756266">More...</a><br/></td></tr>
<tr class="separator:a89d7b1d04892b41e393372edc6756266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3a963e36496e216f6ac21d9ccd7df1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9d3a963e36496e216f6ac21d9ccd7df1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_flow_code_override</b> (int eindex, const <a class="el" href="class_string.html">String</a> &amp;flow_code)</td></tr>
<tr class="separator:a9d3a963e36496e216f6ac21d9ccd7df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9058410d287df65eb5a91c00891f0575"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9058410d287df65eb5a91c00891f0575"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>attachment</b> (const <a class="el" href="class_string.html">String</a> &amp;aname) const </td></tr>
<tr class="separator:a9058410d287df65eb5a91c00891f0575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d944e13a5a2c04622d4b4859c465a82"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d944e13a5a2c04622d4b4859c465a82"></a>
void *&amp;&#160;</td><td class="memItemRight" valign="bottom"><b>force_attachment</b> (const <a class="el" href="class_string.html">String</a> &amp;aname)</td></tr>
<tr class="separator:a6d944e13a5a2c04622d4b4859c465a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6c3260f615a55c90d2b35ad12da62d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c6c3260f615a55c90d2b35ad12da62d"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>set_attachment</b> (const <a class="el" href="class_string.html">String</a> &amp;aname, void *value)</td></tr>
<tr class="separator:a0c6c3260f615a55c90d2b35ad12da62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a07849ced120fa0e9f7b1b1326d5751"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5a07849ced120fa0e9f7b1b1326d5751"></a>
<a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>chatter_channel</b> (const <a class="el" href="class_string.html">String</a> &amp;channel_name) const </td></tr>
<tr class="separator:a5a07849ced120fa0e9f7b1b1326d5751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5405d7b11b10d633d016d4d6dbdeb34"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af5405d7b11b10d633d016d4d6dbdeb34"></a>
HashMap_ArenaFactory *&#160;</td><td class="memItemRight" valign="bottom"><b>arena_factory</b> () const </td></tr>
<tr class="separator:af5405d7b11b10d633d016d4d6dbdeb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22da062a83a85c62a811fa19c1f5983"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab22da062a83a85c62a811fa19c1f5983"></a>
ThreadSched *&#160;</td><td class="memItemRight" valign="bottom"><b>thread_sched</b> () const </td></tr>
<tr class="separator:ab22da062a83a85c62a811fa19c1f5983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad3070d39c40fe35fe857c4860c64cc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acad3070d39c40fe35fe857c4860c64cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_thread_sched</b> (ThreadSched *scheduler)</td></tr>
<tr class="separator:acad3070d39c40fe35fe857c4860c64cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6ec2ecc3897aff2c310335054d24bb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc6ec2ecc3897aff2c310335054d24bb"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>home_thread_id</b> (const <a class="el" href="class_element.html">Element</a> *e) const </td></tr>
<tr class="separator:abc6ec2ecc3897aff2c310335054d24bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75993d164c01b0962c489217adc3226d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75993d164c01b0962c489217adc3226d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_home_thread_id</b> (const <a class="el" href="class_element.html">Element</a> *e, int home_thread)</td></tr>
<tr class="separator:a75993d164c01b0962c489217adc3226d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0425632f3adf69c9b5924e343b21a3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#ac0425632f3adf69c9b5924e343b21a3b">configuration_string</a> () const </td></tr>
<tr class="memdesc:ac0425632f3adf69c9b5924e343b21a3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the router's initial configuration string.  <a href="#ac0425632f3adf69c9b5924e343b21a3b">More...</a><br/></td></tr>
<tr class="separator:ac0425632f3adf69c9b5924e343b21a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d319d8ff350e69bb6c3a3e821f932b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a12d319d8ff350e69bb6c3a3e821f932b">unparse</a> (<a class="el" href="class_string_accum.html">StringAccum</a> &amp;sa, const <a class="el" href="class_string.html">String</a> &amp;indent=<a class="el" href="class_string.html">String</a>()) const </td></tr>
<tr class="memdesc:a12d319d8ff350e69bb6c3a3e821f932b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unparse this router into <em>sa</em>.  <a href="#a12d319d8ff350e69bb6c3a3e821f932b">More...</a><br/></td></tr>
<tr class="separator:a12d319d8ff350e69bb6c3a3e821f932b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f753297208b3af535e08accac55c7c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a2f753297208b3af535e08accac55c7c7">unparse_requirements</a> (<a class="el" href="class_string_accum.html">StringAccum</a> &amp;sa, const <a class="el" href="class_string.html">String</a> &amp;indent=<a class="el" href="class_string.html">String</a>()) const </td></tr>
<tr class="memdesc:a2f753297208b3af535e08accac55c7c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unparse the router's requirements into <em>sa</em>.  <a href="#a2f753297208b3af535e08accac55c7c7">More...</a><br/></td></tr>
<tr class="separator:a2f753297208b3af535e08accac55c7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc347bc64f631f3d7c4f4efb59abb20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#abdc347bc64f631f3d7c4f4efb59abb20">unparse_declarations</a> (<a class="el" href="class_string_accum.html">StringAccum</a> &amp;sa, const <a class="el" href="class_string.html">String</a> &amp;indent=<a class="el" href="class_string.html">String</a>()) const </td></tr>
<tr class="memdesc:abdc347bc64f631f3d7c4f4efb59abb20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unparse declarations of the router's elements into <em>sa</em>.  <a href="#abdc347bc64f631f3d7c4f4efb59abb20">More...</a><br/></td></tr>
<tr class="separator:abdc347bc64f631f3d7c4f4efb59abb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc81821c5541fb998d0ef072e2cb1ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a1dc81821c5541fb998d0ef072e2cb1ea">unparse_connections</a> (<a class="el" href="class_string_accum.html">StringAccum</a> &amp;sa, const <a class="el" href="class_string.html">String</a> &amp;indent=<a class="el" href="class_string.html">String</a>()) const </td></tr>
<tr class="memdesc:a1dc81821c5541fb998d0ef072e2cb1ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unparse the router's connections into <em>sa</em>.  <a href="#a1dc81821c5541fb998d0ef072e2cb1ea">More...</a><br/></td></tr>
<tr class="separator:a1dc81821c5541fb998d0ef072e2cb1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89bfd2f95d3683cf3b51b97c9d3ee08f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a89bfd2f95d3683cf3b51b97c9d3ee08f">element_ports_string</a> (const <a class="el" href="class_element.html">Element</a> *e) const </td></tr>
<tr class="memdesc:a89bfd2f95d3683cf3b51b97c9d3ee08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string representing <em>e's</em> ports.  <a href="#a89bfd2f95d3683cf3b51b97c9d3ee08f">More...</a><br/></td></tr>
<tr class="separator:a89bfd2f95d3683cf3b51b97c9d3ee08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6701e9660cc292f098b20c37faedfd7e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a6701e9660cc292f098b20c37faedfd7e">element</a> (const <a class="el" href="class_router.html">Router</a> *router, int i)</td></tr>
<tr class="memdesc:a6701e9660cc292f098b20c37faedfd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <em>router's</em> element with index <em>eindex</em>.  <a href="#a6701e9660cc292f098b20c37faedfd7e">More...</a><br/></td></tr>
<tr class="separator:a6701e9660cc292f098b20c37faedfd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a87215d66c104877a914c784fb0427"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_handler.html">Handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a15a87215d66c104877a914c784fb0427">handler</a> (const <a class="el" href="class_element.html">Element</a> *e, const <a class="el" href="class_string.html">String</a> &amp;hname)</td></tr>
<tr class="memdesc:a15a87215d66c104877a914c784fb0427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return element <em>e's</em> handler named <em>hname</em>.  <a href="#a15a87215d66c104877a914c784fb0427">More...</a><br/></td></tr>
<tr class="separator:a15a87215d66c104877a914c784fb0427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54040e26f6062f5e1fb109bbaef58f57"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a54040e26f6062f5e1fb109bbaef58f57">add_read_handler</a> (const <a class="el" href="class_element.html">Element</a> *e, const <a class="el" href="class_string.html">String</a> &amp;hname, ReadHandlerCallback callback, void *user_data, uint32_t flags=0)</td></tr>
<tr class="memdesc:a54040e26f6062f5e1fb109bbaef58f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an <em>e</em>.<em>hname</em> read handler.  <a href="#a54040e26f6062f5e1fb109bbaef58f57">More...</a><br/></td></tr>
<tr class="separator:a54040e26f6062f5e1fb109bbaef58f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24506500f646dcc8ea6803807814a64"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#aa24506500f646dcc8ea6803807814a64">add_write_handler</a> (const <a class="el" href="class_element.html">Element</a> *e, const <a class="el" href="class_string.html">String</a> &amp;hname, WriteHandlerCallback callback, void *user_data, uint32_t flags=0)</td></tr>
<tr class="memdesc:aa24506500f646dcc8ea6803807814a64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an <em>e</em>.<em>hname</em> write handler.  <a href="#aa24506500f646dcc8ea6803807814a64">More...</a><br/></td></tr>
<tr class="separator:aa24506500f646dcc8ea6803807814a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac219c8731ddb3dbbb08d2724c32e32ec"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#ac219c8731ddb3dbbb08d2724c32e32ec">set_handler</a> (const <a class="el" href="class_element.html">Element</a> *e, const <a class="el" href="class_string.html">String</a> &amp;hname, uint32_t flags, HandlerCallback callback, void *read_user_data=0, void *write_user_data=0)</td></tr>
<tr class="memdesc:ac219c8731ddb3dbbb08d2724c32e32ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a comprehensive <em>e</em>.<em>hname</em> handler.  <a href="#ac219c8731ddb3dbbb08d2724c32e32ec">More...</a><br/></td></tr>
<tr class="separator:ac219c8731ddb3dbbb08d2724c32e32ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837d04d19614b41dac07c97f547e356d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a837d04d19614b41dac07c97f547e356d">set_handler_flags</a> (const <a class="el" href="class_element.html">Element</a> *e, const <a class="el" href="class_string.html">String</a> &amp;hname, uint32_t set_flags, uint32_t clear_flags=0)</td></tr>
<tr class="memdesc:a837d04d19614b41dac07c97f547e356d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the <em>e</em>.<em>hname</em> handler's flags.  <a href="#a837d04d19614b41dac07c97f547e356d">More...</a><br/></td></tr>
<tr class="separator:a837d04d19614b41dac07c97f547e356d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f27682925a15a07acf9694cb6271e2a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a4f27682925a15a07acf9694cb6271e2a">hindex</a> (const <a class="el" href="class_element.html">Element</a> *e, const <a class="el" href="class_string.html">String</a> &amp;hname)</td></tr>
<tr class="memdesc:a4f27682925a15a07acf9694cb6271e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the handler index for element <em>e's</em> handler named <em>hname</em>.  <a href="#a4f27682925a15a07acf9694cb6271e2a">More...</a><br/></td></tr>
<tr class="separator:a4f27682925a15a07acf9694cb6271e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6813a52aee1c2f3f937cb80706794172"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_handler.html">Handler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a6813a52aee1c2f3f937cb80706794172">handler</a> (const <a class="el" href="class_router.html">Router</a> *router, int <a class="el" href="class_router.html#a4f27682925a15a07acf9694cb6271e2a">hindex</a>)</td></tr>
<tr class="memdesc:a6813a52aee1c2f3f937cb80706794172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <em>router's</em> handler with index <em>hindex</em>.  <a href="#a6813a52aee1c2f3f937cb80706794172">More...</a><br/></td></tr>
<tr class="separator:a6813a52aee1c2f3f937cb80706794172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06da840971bee4e4fc7efbb19e33193"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#ad06da840971bee4e4fc7efbb19e33193">element_hindexes</a> (const <a class="el" href="class_element.html">Element</a> *e, <a class="el" href="class_vector.html">Vector</a>&lt; int &gt; &amp;result)</td></tr>
<tr class="memdesc:ad06da840971bee4e4fc7efbb19e33193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the handler indexes for element <em>e's</em> handlers.  <a href="#ad06da840971bee4e4fc7efbb19e33193">More...</a><br/></td></tr>
<tr class="separator:ad06da840971bee4e4fc7efbb19e33193"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Internal Functions</h2></td></tr>
<tr class="memitem:a8bda5ccf669181669a38d4ba256afaa9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a8bda5ccf669181669a38d4ba256afaa9">Router</a> (const <a class="el" href="class_string.html">String</a> &amp;configuration, Master *<a class="el" href="class_router.html#ac7f0e296cf498fe08cb4d91bcf310e44">master</a>)</td></tr>
<tr class="memdesc:a8bda5ccf669181669a38d4ba256afaa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a router.  <a href="#a8bda5ccf669181669a38d4ba256afaa9">More...</a><br/></td></tr>
<tr class="separator:a8bda5ccf669181669a38d4ba256afaa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d13a6259937e330488653e8e16f921"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a26d13a6259937e330488653e8e16f921">~Router</a> ()</td></tr>
<tr class="memdesc:a26d13a6259937e330488653e8e16f921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the router.  <a href="#a26d13a6259937e330488653e8e16f921">More...</a><br/></td></tr>
<tr class="separator:a26d13a6259937e330488653e8e16f921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f39faf9ebc7c3440c9c45bd8f7147e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#ab7f39faf9ebc7c3440c9c45bd8f7147e">use</a> ()</td></tr>
<tr class="memdesc:ab7f39faf9ebc7c3440c9c45bd8f7147e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the router's reference count.  <a href="#ab7f39faf9ebc7c3440c9c45bd8f7147e">More...</a><br/></td></tr>
<tr class="separator:ab7f39faf9ebc7c3440c9c45bd8f7147e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420a7cbbff6e74b0db2379a83e387b22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a420a7cbbff6e74b0db2379a83e387b22">unuse</a> ()</td></tr>
<tr class="memdesc:a420a7cbbff6e74b0db2379a83e387b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrement the router's reference count.  <a href="#a420a7cbbff6e74b0db2379a83e387b22">More...</a><br/></td></tr>
<tr class="separator:a420a7cbbff6e74b0db2379a83e387b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad942e96bc930e9ace804fb07d2ccf0d6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad942e96bc930e9ace804fb07d2ccf0d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>add_requirement</b> (const <a class="el" href="class_string.html">String</a> &amp;type, const <a class="el" href="class_string.html">String</a> &amp;value)</td></tr>
<tr class="separator:ad942e96bc930e9ace804fb07d2ccf0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6c5c259fe30d572035cb48b8fed42e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc6c5c259fe30d572035cb48b8fed42e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>add_element</b> (<a class="el" href="class_element.html">Element</a> *e, const <a class="el" href="class_string.html">String</a> &amp;name, const <a class="el" href="class_string.html">String</a> &amp;conf, const <a class="el" href="class_string.html">String</a> &amp;filename, unsigned lineno)</td></tr>
<tr class="separator:afc6c5c259fe30d572035cb48b8fed42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4da3b9d5df3a030304432a16d58b18"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b4da3b9d5df3a030304432a16d58b18"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>add_connection</b> (int from_idx, int from_port, int to_idx, int to_port)</td></tr>
<tr class="separator:a0b4da3b9d5df3a030304432a16d58b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3b045666f437d2fd7ffc9da91fd6ba"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abc3b045666f437d2fd7ffc9da91fd6ba"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>add_module_ref</b> (struct module *module)</td></tr>
<tr class="separator:abc3b045666f437d2fd7ffc9da91fd6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8ff9d773631cd072c2571ec39f568c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_router.html">Router</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#a0a8ff9d773631cd072c2571ec39f568c">hotswap_router</a> () const </td></tr>
<tr class="memdesc:a0a8ff9d773631cd072c2571ec39f568c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently-installed router this router will eventually replace.  <a href="#a0a8ff9d773631cd072c2571ec39f568c">More...</a><br/></td></tr>
<tr class="separator:a0a8ff9d773631cd072c2571ec39f568c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114cf46f456cbaff58495f968f82d358"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a114cf46f456cbaff58495f968f82d358"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_hotswap_router</b> (<a class="el" href="class_router.html">Router</a> *router)</td></tr>
<tr class="separator:a114cf46f456cbaff58495f968f82d358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd5accc7c007af8479bade9c582af2b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1dd5accc7c007af8479bade9c582af2b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>initialize</b> (<a class="el" href="class_error_handler.html">ErrorHandler</a> *errh)</td></tr>
<tr class="separator:a1dd5accc7c007af8479bade9c582af2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e97510264776c0e9aef740a3d5b6d5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a01e97510264776c0e9aef740a3d5b6d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>activate</b> (bool foreground, <a class="el" href="class_error_handler.html">ErrorHandler</a> *errh)</td></tr>
<tr class="separator:a01e97510264776c0e9aef740a3d5b6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a18943591cf0147a2e0af0d51819d53"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1a18943591cf0147a2e0af0d51819d53"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>activate</b> (<a class="el" href="class_error_handler.html">ErrorHandler</a> *errh)</td></tr>
<tr class="separator:a1a18943591cf0147a2e0af0d51819d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c2d651fa47b4a4d5d2e020c2459475"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa5c2d651fa47b4a4d5d2e020c2459475"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_foreground</b> (bool foreground)</td></tr>
<tr class="separator:aa5c2d651fa47b4a4d5d2e020c2459475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43fd6bdbe237dc480ed0e1fd419e313"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_router.html#ad43fd6bdbe237dc480ed0e1fd419e313">new_notifier_signal</a> (const char *name, <a class="el" href="class_notifier_signal.html">NotifierSignal</a> &amp;signal)</td></tr>
<tr class="memdesc:ad43fd6bdbe237dc480ed0e1fd419e313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new basic signal.  <a href="#ad43fd6bdbe237dc480ed0e1fd419e313">More...</a><br/></td></tr>
<tr class="separator:ad43fd6bdbe237dc480ed0e1fd419e313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72559b5e258ae5a449c822e81622c1b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72559b5e258ae5a449c822e81622c1b7"></a>
<a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><b>notifier_signal_name</b> (const <a class="el" href="classatomic__uint32__t.html">atomic_uint32_t</a> *signal) const </td></tr>
<tr class="separator:a72559b5e258ae5a449c822e81622c1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe82fdc12c9ecb3b8fd5c274da0a4e5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9fe82fdc12c9ecb3b8fd5c274da0a4e5"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>static_initialize</b> ()</td></tr>
<tr class="separator:a9fe82fdc12c9ecb3b8fd5c274da0a4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee0d56cc2536a19ce037b4a7b612f7d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaee0d56cc2536a19ce037b4a7b612f7d"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>static_cleanup</b> ()</td></tr>
<tr class="separator:aaee0d56cc2536a19ce037b4a7b612f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A router configuration. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8bda5ccf669181669a38d4ba256afaa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Router::Router </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>configuration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Master *&#160;</td>
          <td class="paramname"><em>master</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a router. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">configuration</td><td>router configuration </td></tr>
    <tr><td class="paramname">master</td><td>Master object</td></tr>
  </table>
  </dd>
</dl>
<p>Users generally do not call this function directly, instead creating a router object by calling Lexer functions (this function doesn't actually parse the configuration string). The router is registered with the Master object, but not initialized or activated. </p>

</div>
</div>
<a class="anchor" id="a26d13a6259937e330488653e8e16f921"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Router::~Router </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the router. </p>
<dl class="section invariant"><dt>Invariant</dt><dd>The reference count must be zero.</dd></dl>
<p>Users generally do not destroy <a class="el" href="class_router.html" title="A router configuration. ">Router</a> objects directly, instead calling <a class="el" href="class_router.html#a420a7cbbff6e74b0db2379a83e387b22" title="Decrement the router&#39;s reference count. ">Router::unuse()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ac7f0e296cf498fe08cb4d91bcf310e44"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Master * Router::master </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the Master object for this router. </p>
<p>never </p>

</div>
</div>
<a class="anchor" id="a96b7ee23654ecac1d53ed31bf5ef89e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Router::initialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true iff the router has been successfully initialized. </p>

</div>
</div>
<a class="anchor" id="a002689f7932e1915559c5a984fe72609"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Router::handlers_ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true iff the router's handlers have been initialized. </p>
<p><a class="el" href="class_router.html#a002689f7932e1915559c5a984fe72609" title="Return true iff the router&#39;s handlers have been initialized. ">handlers_ready()</a> returns false until each element's <a class="el" href="class_element.html#a65a2efbc7c6af095d16cf31015e9216f" title="Install the element&#39;s handlers. ">Element::add_handlers()</a> method has been called. This happens after <a class="el" href="class_element.html#ab2bb58f562728df47d007fd12a9e92f4" title="Parse the element&#39;s configuration arguments. ">Element::configure()</a>, but before <a class="el" href="class_element.html#abf2bbb7d3ae5a1372a6af9d7bb8269fe" title="Initialize the element. ">Element::initialize()</a>. </p>

</div>
</div>
<a class="anchor" id="a071badc0da30370e78e972e3749bc31a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Router::running </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true iff the router is currently running. </p>
<p>A running router has been successfully initialized (so <a class="el" href="class_router.html#a071badc0da30370e78e972e3749bc31a" title="Return true iff the router is currently running. ">running()</a> implies <a class="el" href="class_router.html#a96b7ee23654ecac1d53ed31bf5ef89e0" title="Return true iff the router has been successfully initialized. ">initialized()</a>), and has not stopped yet. </p>

</div>
</div>
<a class="anchor" id="a0d64a7777fc6bb4482ae25ccc0725bfb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Router::dying </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true iff the router is in the process of being killed. </p>

</div>
</div>
<a class="anchor" id="acdddb3c9cd1ee804773bcb98ba8771fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Router::runcount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the router's runcount. </p>
<p>The runcount is an integer that determines whether the router is running. A running router has positive runcount. Decrementing the router's runcount to zero or below will cause the router to stop, although elements like DriverManager can intercept the stop request and continue processing.</p>
<p>Elements request that the router stop its processing by calling <a class="el" href="class_router.html#a3c655b7607d14c1c348a02da235d5bba" title="Adjust the runcount by delta. ">adjust_runcount()</a> or <a class="el" href="class_router.html#a47550fb34c0e88beadb5633ba7c69dd1" title="Request a driver stop by adjusting the runcount by -1. ">please_stop_driver()</a>. </p>

</div>
</div>
<a class="anchor" id="a3c655b7607d14c1c348a02da235d5bba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Router::adjust_runcount </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adjust the runcount by <em>delta</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delta</td><td>runcount adjustment</td></tr>
  </table>
  </dd>
</dl>
<p>Essentially performs the assignment "runcount += delta" with compensation for integer overflow. (For instance, if runcount is INT_MAX and delta is INT_MAX, the resulting runcount will be INT_MAX, not -2.) Uses atomic operations to ensure that runcount adjustments are not lost.</p>
<p>If the adjusted runcount is zero or negative, the router is asked to stop its normal processing. This will happen soon, although not necessarily immediately. Once it stops, the router will search for an element to manage the stop event (see the Script and DriverManager elements). If no such element exists, or the script completes without raising the runcount, the router stops permanently. </p>

</div>
</div>
<a class="anchor" id="a3d36190f5dd3500d8e9dc591ab03aa33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Router::set_runcount </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>rc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the runcount. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rc</td><td>new runcount</td></tr>
  </table>
  </dd>
</dl>
<p>Sets the runcount to a specific value. If the new runcount is zero or negative, stops the router; see <a class="el" href="class_router.html#a3c655b7607d14c1c348a02da235d5bba" title="Adjust the runcount by delta. ">adjust_runcount()</a>. </p>

</div>
</div>
<a class="anchor" id="a47550fb34c0e88beadb5633ba7c69dd1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Router::please_stop_driver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Request a driver stop by adjusting the runcount by -1. </p>
<dl class="section note"><dt>Note</dt><dd>Equivalent to adjust_runcount(-1). </dd></dl>

</div>
</div>
<a class="anchor" id="a7ad0fe36c507dbdafec994133f816e75"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_element.html">Element</a> * &gt; &amp; Router::elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector containing all the router's elements. </p>
<dl class="section invariant"><dt>Invariant</dt><dd><a class="el" href="class_router.html#a7ad0fe36c507dbdafec994133f816e75" title="Returns a vector containing all the router&#39;s elements. ">elements()</a>[i] == element(i) for all i in range. </dd></dl>

</div>
</div>
<a class="anchor" id="adc2dc075a870b8d7163f20b3fa05c68a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Router::nelements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of elements in the router. </p>

</div>
</div>
<a class="anchor" id="a7737aa7500d9be28d537a8aad165b493"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_element.html">Element</a> * Router::element </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the element with index <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>element index, or -1 for <a class="el" href="class_router.html#a6839bfb0b5a2f27b4b3e41e2fa3fb51c" title="Returns this router&#39;s root element. ">root_element()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section invariant"><dt>Invariant</dt><dd>If element(i) isn't null, then element(i)-&gt;<a class="el" href="class_element.html#ae9f6ee27e9342386aaa3cb5381615cd5">eindex</a>() == i.</dd></dl>
<p>This function returns the element with index <em>i</em>. If <em>i</em> == -1, returns <a class="el" href="class_router.html#a6839bfb0b5a2f27b4b3e41e2fa3fb51c" title="Returns this router&#39;s root element. ">root_element()</a>. If <em>i</em> is otherwise out of range, returns null. </p>

</div>
</div>
<a class="anchor" id="a6839bfb0b5a2f27b4b3e41e2fa3fb51c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_element.html">Element</a> * Router::root_element </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns this router's root element. </p>
<p>Every router has a root <a class="el" href="class_element.html" title="Base class for Click elements. ">Element</a>. This element has <a class="el" href="class_element.html#ae9f6ee27e9342386aaa3cb5381615cd5" title="Return the element&#39;s index within its router. ">Element::eindex()</a> -1 and name "". It is not configured or initialized, and doesn't appear in the configuration; it exists only for convenience, when other Click code needs to refer to some arbitrary element at the top level of the compound element hierarchy. </p>

</div>
</div>
<a class="anchor" id="a6701e9660cc292f098b20c37faedfd7e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_element.html">Element</a> * Router::element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_router.html">Router</a> *&#160;</td>
          <td class="paramname"><em>router</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eindex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <em>router's</em> element with index <em>eindex</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">router</td><td>the router (may be null) </td></tr>
    <tr><td class="paramname">eindex</td><td>element index, or -1 for router-&gt;<a class="el" href="class_router.html#a6839bfb0b5a2f27b4b3e41e2fa3fb51c" title="Returns this router&#39;s root element. ">root_element()</a></td></tr>
  </table>
  </dd>
</dl>
<p>This function returns <em>router's</em> element with index <em>eindex</em>. If <em>router</em> is null or <em>eindex</em> is out of range, returns null. </p>

</div>
</div>
<a class="anchor" id="a5d77740b46817d26e94545a95b4caf70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_string.html">String</a> &amp; Router::ename </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eindex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns element index <em>eindex's</em> name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eindex</td><td>element index</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the empty string if <em>eindex</em> is out of range. </p>

</div>
</div>
<a class="anchor" id="a6a3c308b39e55f460041267dc8ffaed6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_string.html">String</a> Router::ename_context </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eindex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns element index <em>eindex's</em> name context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eindex</td><td>element index</td></tr>
  </table>
  </dd>
</dl>
<p>The result is the context prefix for the element's name. This is the string up to, and including, the last slash in the element's name. Returns the empty string if <em>eindex</em> is out of range. </p>

</div>
</div>
<a class="anchor" id="a6b76acf16b151730739b7fb0ecb30820"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_string.html">String</a> Router::elandmark </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eindex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns element index <em>eindex's</em> landmark. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eindex</td><td>element index</td></tr>
  </table>
  </dd>
</dl>
<p>A landmark is a short string specifying where the element was defined. A typical landmark has the form "file:linenumber", as in <code>"file.click:30"</code>. Returns the empty string if <em>eindex</em> is out of range. </p>

</div>
</div>
<a class="anchor" id="ad616383b1878cd5261ec68086720bb73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_string.html">String</a> &amp; Router::econfiguration </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eindex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns element index <em>eindex's</em> configuration string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eindex</td><td>element index</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the empty string if <em>eindex</em> is out of range.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="class_router.html#ad616383b1878cd5261ec68086720bb73" title="Returns element index eindex&#39;s configuration string. ">econfiguration()</a> returns the element's most recently specified static configuration string, which might differ from the element's active configuration string. For the active configuration, call <a class="el" href="class_element.html#a4c909e3f64f1104e0c70a5acc53166a0" title="Return the element&#39;s current configuration string. ">Element::configuration()</a>, which might include post-initialization changes. </dd></dl>

</div>
</div>
<a class="anchor" id="a403eb46153271a67d3cb78883d74273f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Router::set_econfiguration </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eindex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets element index <em>eindex's</em> configuration string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eindex</td><td>element index </td></tr>
    <tr><td class="paramname">conf</td><td>configuration string</td></tr>
  </table>
  </dd>
</dl>
<p>Does nothing if <em>eindex</em> is out of range. </p>

</div>
</div>
<a class="anchor" id="a3f0c4986f3f4763dce781bba80c741c2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_element.html">Element</a> * Router::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds an element named <em>name</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>element name </td></tr>
    <tr><td class="paramname">errh</td><td>optional error handler</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the unique element named <em>name</em>, if any. If no element named <em>name</em> is found, reports an error to <em>errh</em> and returns null. The error is "&lt;tt&gt;no element named 'name'&lt;/tt&gt;". If <em>errh</em> is null, no error is reported.</p>
<p>This function is equivalent to find(const String&amp;, String, ErrorHandler*) with a context argument of the empty string. </p>

</div>
</div>
<a class="anchor" id="a6745f4de754fdffc93d710949bd5a4cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_element.html">Element</a> * Router::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_string.html">String</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an element named <em>name</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>element name </td></tr>
    <tr><td class="paramname">context</td><td>compound element context </td></tr>
    <tr><td class="paramname">errh</td><td>optional error handler</td></tr>
  </table>
  </dd>
</dl>
<p>Searches for an element named <em>name</em> in the compound element context specified by <em>context</em>, returning the first element found. For example, if <em>context</em> was <code>"aaa/bbb/ccc/"</code>, then <a class="el" href="class_router.html#a3f0c4986f3f4763dce781bba80c741c2" title="Finds an element named name. ">find()</a> would search for elements named <code>aaa/bbb/ccc/name</code>, <code>aaa/bbb/name</code>, <code>aaa/name</code>, and finally <code>name</code>, returning the first element found. If nonempty, <em>context</em> should end with a slash.</p>
<p>If no element named <em>name</em> is found, reports an error to <em>errh</em> and returns null. The error is "&lt;tt&gt;no element named 'name'&lt;/tt&gt;". If <em>errh</em> is null, no error is reported. </p>

</div>
</div>
<a class="anchor" id="a48a957f736c4de4aa54709cd69020f89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_element.html">Element</a> * Router::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds an element named <em>name</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>element name </td></tr>
    <tr><td class="paramname">context</td><td>compound element context </td></tr>
    <tr><td class="paramname">errh</td><td>optional error handler</td></tr>
  </table>
  </dd>
</dl>
<p>Searches for an element named <em>name</em> in the compound element context specified by <em>context</em>, returning the first element found. For example, if ename(<em>context</em>) was <code>"aaa/bbb/element"</code>, then find(<em>name</em>, <em>context</em>, <em>errh</em>) is equivalent to find(<em>name</em>, <code>"aaa/bbb/"</code>, <em>errh</em>), and will search for elements named <code>aaa/bbb/name</code>, <code>aaa/name</code>, and finally <code>name</code>.</p>
<p>If no element named <em>name</em> is found, reports an error to <em>errh</em> and returns null. The error is "&lt;tt&gt;no element named 'name'&lt;/tt&gt;". If <em>errh</em> is null, no error is reported. </p>

</div>
</div>
<a class="anchor" id="a0583b91f9217950a2059ccb94e7f9d1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Router::visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>first_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_router_visitor.html">RouterVisitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Traverse the router configuration from one of <em>e's</em> ports. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>element to start search </td></tr>
    <tr><td class="paramname">forward</td><td>true to search down from outputs, false to search up from inputs </td></tr>
    <tr><td class="paramname">port</td><td>port (or -1 to search all ports) </td></tr>
    <tr><td class="paramname">visitor</td><td><a class="el" href="class_router_visitor.html" title="Base class for router configuration visitors. ">RouterVisitor</a> traversal object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 in early router configuration stages</dd></dl>
<p>Calls <em>visitor</em> -&gt;<a class="el" href="class_router_visitor.html#add5a9ec854704bdba215e06f1cc59f56">visit() </a> on each reachable port starting from a port on <em>e</em>. Follows connections and traverses inside elements from port to port by <a class="el" href="class_element.html#acb359ed32700d440149ba50cea37ae8b" title="Return the element&#39;s internal packet flow specifier (its flow code). ">Element::flow_code()</a>. The visitor can stop a traversal path by returning false from <a class="el" href="class_router.html#a0583b91f9217950a2059ccb94e7f9d1b" title="Traverse the router configuration from one of e&#39;s ports. ">visit()</a>.</p>
<p><em>visitor</em> -&gt;<a class="el" href="class_router_visitor.html#add5a9ec854704bdba215e06f1cc59f56">visit() is called on input ports if <em>forward</em> is true and output ports if <em>forward</em> is false. Equivalent to either visit_downstream() or visit_upstream(), depending on <em>forward</em>  visit_downstream(), visit_upstream() </a></p>

</div>
</div>
<a class="anchor" id="a31864307d3183dc2c705d6b8ccf9dc66"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Router::visit_downstream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_router_visitor.html">RouterVisitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverse the router configuration downstream of <em>e</em>[<em>port</em>]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>element to start search </td></tr>
    <tr><td class="paramname">port</td><td>output port (or -1 to search all output ports) </td></tr>
    <tr><td class="paramname">visitor</td><td><a class="el" href="class_router_visitor.html" title="Base class for router configuration visitors. ">RouterVisitor</a> traversal object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 in early router configuration stages</dd></dl>
<p>Calls <em>visitor</em> -&gt;<a class="el" href="class_router_visitor.html#add5a9ec854704bdba215e06f1cc59f56">visit() </a> on each reachable input port starting from the output port <em>e</em>[<em>port</em>]. Follows connections and traverses inside elements from port to port by <a class="el" href="class_element.html#acb359ed32700d440149ba50cea37ae8b" title="Return the element&#39;s internal packet flow specifier (its flow code). ">Element::flow_code()</a>. The visitor can stop a traversal path by returning false from <a class="el" href="class_router.html#a0583b91f9217950a2059ccb94e7f9d1b" title="Traverse the router configuration from one of e&#39;s ports. ">visit()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_router.html#ab287fdc68a04983b010b879ce4a6a3cb" title="Traverse the router configuration upstream of [port]e. ">visit_upstream()</a>, <a class="el" href="class_router.html#a0583b91f9217950a2059ccb94e7f9d1b" title="Traverse the router configuration from one of e&#39;s ports. ">visit()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab287fdc68a04983b010b879ce4a6a3cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Router::visit_upstream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_router_visitor.html">RouterVisitor</a> *&#160;</td>
          <td class="paramname"><em>visitor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Traverse the router configuration upstream of [<em>port</em>]<em>e</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>element to start search </td></tr>
    <tr><td class="paramname">port</td><td>input port (or -1 to search all input ports) </td></tr>
    <tr><td class="paramname">visitor</td><td><a class="el" href="class_router_visitor.html" title="Base class for router configuration visitors. ">RouterVisitor</a> traversal object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 in early router configuration stages</dd></dl>
<p>Calls <em>visitor</em> -&gt;<a class="el" href="class_router_visitor.html#add5a9ec854704bdba215e06f1cc59f56">visit() </a> on each reachable output port starting from the input port [<em>port</em>]<em>e</em>. Follows connections and traverses inside elements from port to port by <a class="el" href="class_element.html#acb359ed32700d440149ba50cea37ae8b" title="Return the element&#39;s internal packet flow specifier (its flow code). ">Element::flow_code()</a>. The visitor can stop a traversal path by returning false from <a class="el" href="class_router.html#a0583b91f9217950a2059ccb94e7f9d1b" title="Traverse the router configuration from one of e&#39;s ports. ">visit()</a>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_router.html#a31864307d3183dc2c705d6b8ccf9dc66" title="Traverse the router configuration downstream of e[port]. ">visit_downstream()</a>, <a class="el" href="class_router.html#a0583b91f9217950a2059ccb94e7f9d1b" title="Traverse the router configuration from one of e&#39;s ports. ">visit()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aefbd96196a5f435296bc2a9a977413ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Router::downstream_elements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_element_filter.html">ElementFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_element.html">Element</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for elements downstream from <em>e</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>element to start search </td></tr>
    <tr><td class="paramname">port</td><td>output port (or -1 to search all output ports) </td></tr>
    <tr><td class="paramname">filter</td><td><a class="el" href="class_element_filter.html" title="Base class for filter predicates for elements and ports. ">ElementFilter</a> naming elements that stop the search </td></tr>
    <tr><td class="paramname">result</td><td>stores results </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 in early router configuration stages</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000024">Deprecated:</a></b></dt><dd>This function is deprecated. Use <a class="el" href="class_router.html#a31864307d3183dc2c705d6b8ccf9dc66" title="Traverse the router configuration downstream of e[port]. ">visit_downstream()</a> instead.</dd></dl>
<p>This function searches the router configuration graph, starting from <em>e's</em> output port <em>port</em> and proceeding downstream along element connections, and inside elements from port to port by <a class="el" href="class_element.html#acb359ed32700d440149ba50cea37ae8b" title="Return the element&#39;s internal packet flow specifier (its flow code). ">Element::flow_code()</a>. All found elements are stored in <em>result</em>.</p>
<p>If <em>filter</em> != NULL, then each found port is passed to <em>filter's</em> <a class="el" href="class_element_filter.html#a6def86988fad65d385ce5c795b100b13" title="Determine whether an element or port matches this filter. ">ElementFilter::check_match()</a> function to check whether to stop the search. For example, if <em>filter</em> is <a class="el" href="class_cast_element_filter.html" title="Cast-based filter predicate for elements. ">CastElementFilter</a>("Storage"), then the search will stop after any Storage element. The <em>result</em> will then include the Storage elements and any elements in between <em>e</em> and the Storage elements.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_router.html#ad64f8eff036d8d8b18ae9aeb2bf63623" title="Search for elements upstream from e. ">upstream_elements()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad64f8eff036d8d8b18ae9aeb2bf63623"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Router::upstream_elements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_element_filter.html">ElementFilter</a> *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_element.html">Element</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search for elements upstream from <em>e</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>element to start search </td></tr>
    <tr><td class="paramname">port</td><td>input port (or -1 to search all ports) </td></tr>
    <tr><td class="paramname">filter</td><td><a class="el" href="class_element_filter.html" title="Base class for filter predicates for elements and ports. ">ElementFilter</a> naming elements that stop the search </td></tr>
    <tr><td class="paramname">result</td><td>stores results </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 in early router configuration stages</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000025">Deprecated:</a></b></dt><dd>This function is deprecated. Use <a class="el" href="class_router.html#ab287fdc68a04983b010b879ce4a6a3cb" title="Traverse the router configuration upstream of [port]e. ">visit_upstream()</a> instead.</dd></dl>
<p>This function searches the router configuration graph, starting from <em>e's</em> input port <em>port</em> and proceeding upstream along element connections, and inside elements from port to port by <a class="el" href="class_element.html#acb359ed32700d440149ba50cea37ae8b" title="Return the element&#39;s internal packet flow specifier (its flow code). ">Element::flow_code()</a>. All found elements are stored in <em>result</em>.</p>
<p>If <em>filter</em> != NULL, then each found port is passed to <em>filter's</em> <a class="el" href="class_element_filter.html#a6def86988fad65d385ce5c795b100b13" title="Determine whether an element or port matches this filter. ">ElementFilter::check_match()</a> function to check whether to stop the search. For example, if <em>filter</em> is <a class="el" href="class_cast_element_filter.html" title="Cast-based filter predicate for elements. ">CastElementFilter</a>("Storage"), then the search will stop after any Storage element. The <em>result</em> will then include the Storage elements and any elements in between <em>e</em> and the Storage elements.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_router.html#aefbd96196a5f435296bc2a9a977413ad" title="Search for elements downstream from e. ">downstream_elements()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a89d7b1d04892b41e393372edc6756266"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * Router::flow_code_override </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>eindex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the overriding flow code for element <em>e</em>, if any. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eindex</td><td>element index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The flow code, or null if none has been set. </dd></dl>

</div>
</div>
<a class="anchor" id="a15a87215d66c104877a914c784fb0427"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_handler.html">Handler</a> * Router::handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>hname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return element <em>e's</em> handler named <em>hname</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>element, if any </td></tr>
    <tr><td class="paramname">hname</td><td>handler name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_handler.html" title="Represents a router&#39;s handlers. ">Handler</a>, or null if no such handler exists</dd></dl>
<p>Searches for element <em>e's</em> handler named <em>hname</em>. Returns NULL if no such handler exists. If <em>e</em> is NULL or equal to some <a class="el" href="class_router.html#a6839bfb0b5a2f27b4b3e41e2fa3fb51c" title="Returns this router&#39;s root element. ">root_element()</a>, then this function searches for a global handler named <em>hname</em>.</p>
<p>The return <a class="el" href="class_handler.html" title="Represents a router&#39;s handlers. ">Handler</a> pointer remains valid until the named handler is changed in some way (<a class="el" href="class_router.html#a54040e26f6062f5e1fb109bbaef58f57" title="Add an e.hname read handler. ">add_read_handler()</a>, <a class="el" href="class_router.html#aa24506500f646dcc8ea6803807814a64" title="Add an e.hname write handler. ">add_write_handler()</a>, <a class="el" href="class_router.html#ac219c8731ddb3dbbb08d2724c32e32ec" title="Add a comprehensive e.hname handler. ">set_handler()</a>, or <a class="el" href="class_router.html#a837d04d19614b41dac07c97f547e356d" title="Change the e.hname handler&#39;s flags. ">set_handler_flags()</a>). </p>

</div>
</div>
<a class="anchor" id="a54040e26f6062f5e1fb109bbaef58f57"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Router::add_read_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>hname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandlerCallback&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an <em>e</em>.<em>hname</em> read handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>element, if any </td></tr>
    <tr><td class="paramname">hname</td><td>handler name </td></tr>
    <tr><td class="paramname">callback</td><td>read callback </td></tr>
    <tr><td class="paramname">user_data</td><td>user data for read callback </td></tr>
    <tr><td class="paramname">flags</td><td>additional flags to set (<a class="el" href="class_handler.html#a007e8050210701c7fa4ce3b087d4f8fe" title="Return this handler&#39;s flags. ">Handler::flags()</a>)</td></tr>
  </table>
  </dd>
</dl>
<p>Adds a read handler named <em>hname</em> for element <em>e</em>. If <em>e</em> is NULL or equal to some <a class="el" href="class_router.html#a6839bfb0b5a2f27b4b3e41e2fa3fb51c" title="Returns this router&#39;s root element. ">root_element()</a>, then adds a global read handler. The handler's callback function is <em>callback</em>. When the read handler is triggered, Click will call <em>callback</em>(<em>e</em>, <em>user_data</em>).</p>
<p>Any previous read handler with the same name and element is replaced. Any comprehensive handler function (see <a class="el" href="class_router.html#ac219c8731ddb3dbbb08d2724c32e32ec" title="Add a comprehensive e.hname handler. ">set_handler()</a>) is replaced. Any write-only handler (<a class="el" href="class_router.html#aa24506500f646dcc8ea6803807814a64" title="Add an e.hname write handler. ">add_write_handler()</a>) remains.</p>
<p>The new handler's flags equal the old flags or'ed with <em>flags</em>. Any special flags in <em>flags</em> are ignored.</p>
<p>To create a read handler with parameters, you must use <em><a class="el" href="class_router.html#ac219c8731ddb3dbbb08d2724c32e32ec" title="Add a comprehensive e.hname handler. ">set_handler()</a></em>.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_router.html#aa24506500f646dcc8ea6803807814a64" title="Add an e.hname write handler. ">add_write_handler()</a>, <a class="el" href="class_router.html#ac219c8731ddb3dbbb08d2724c32e32ec" title="Add a comprehensive e.hname handler. ">set_handler()</a>, <a class="el" href="class_router.html#a837d04d19614b41dac07c97f547e356d" title="Change the e.hname handler&#39;s flags. ">set_handler_flags()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa24506500f646dcc8ea6803807814a64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Router::add_write_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>hname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandlerCallback&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an <em>e</em>.<em>hname</em> write handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>element, if any </td></tr>
    <tr><td class="paramname">hname</td><td>handler name </td></tr>
    <tr><td class="paramname">callback</td><td>read callback </td></tr>
    <tr><td class="paramname">user_data</td><td>user data for write callback </td></tr>
    <tr><td class="paramname">flags</td><td>additional flags to set (<a class="el" href="class_handler.html#a007e8050210701c7fa4ce3b087d4f8fe" title="Return this handler&#39;s flags. ">Handler::flags()</a>)</td></tr>
  </table>
  </dd>
</dl>
<p>Adds a write handler named <em>hname</em> for element <em>e</em>. If <em>e</em> is NULL or equal to some <a class="el" href="class_router.html#a6839bfb0b5a2f27b4b3e41e2fa3fb51c" title="Returns this router&#39;s root element. ">root_element()</a>, then adds a global write handler. The handler's callback function is <em>callback</em>. When the write handler is triggered, Click will call <em>callback</em>(data, <em>e</em>, <em>user_data</em>, errh).</p>
<p>Any previous write handler with the same name and element is replaced. Any comprehensive handler function (see <a class="el" href="class_router.html#ac219c8731ddb3dbbb08d2724c32e32ec" title="Add a comprehensive e.hname handler. ">set_handler()</a>) is replaced. Any read-only handler (<a class="el" href="class_router.html#a54040e26f6062f5e1fb109bbaef58f57" title="Add an e.hname read handler. ">add_read_handler()</a>) remains.</p>
<p>The new handler's flags equal the old flags or'ed with <em>flags</em>. Any special flags in <em>flags</em> are ignored.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_router.html#a54040e26f6062f5e1fb109bbaef58f57" title="Add an e.hname read handler. ">add_read_handler()</a>, <a class="el" href="class_router.html#ac219c8731ddb3dbbb08d2724c32e32ec" title="Add a comprehensive e.hname handler. ">set_handler()</a>, <a class="el" href="class_router.html#a837d04d19614b41dac07c97f547e356d" title="Change the e.hname handler&#39;s flags. ">set_handler_flags()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac219c8731ddb3dbbb08d2724c32e32ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Router::set_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>hname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HandlerCallback&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>read_user_data</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>write_user_data</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a comprehensive <em>e</em>.<em>hname</em> handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>element, if any </td></tr>
    <tr><td class="paramname">hname</td><td>handler name </td></tr>
    <tr><td class="paramname">flags</td><td>flags to set (<a class="el" href="class_handler.html#a007e8050210701c7fa4ce3b087d4f8fe" title="Return this handler&#39;s flags. ">Handler::flags()</a>) </td></tr>
    <tr><td class="paramname">callback</td><td>comprehensive handler callback </td></tr>
    <tr><td class="paramname">read_user_data</td><td>read user data for <em>callback</em> </td></tr>
    <tr><td class="paramname">write_user_data</td><td>write user data for <em>callback</em> </td></tr>
  </table>
  </dd>
</dl>
<p>Sets a handler named <em>hname</em> for element <em>e</em>. If <em>e</em> is NULL or equal to some <a class="el" href="class_router.html#a6839bfb0b5a2f27b4b3e41e2fa3fb51c" title="Returns this router&#39;s root element. ">root_element()</a>, then sets a global handler. The handler's callback function is <em>callback</em>. The resulting handler is a read handler if <em>flags</em> contains <a class="el" href="class_handler.html#ac08417becc781346bef93d6dd440bc55a53839db78e8b48bd46beb3d8cff3f2d3" title="Handler supports read operations. ">Handler::f_read</a>, and a write handler if <em>flags</em> contains <a class="el" href="class_handler.html#ac08417becc781346bef93d6dd440bc55affb8316da8ea607553b43f123b3d6403" title="Handler supports write operations. ">Handler::f_write</a>. If the flags contain <a class="el" href="class_handler.html#ac08417becc781346bef93d6dd440bc55ac5d9adb323bbd4707eef4cca0553c8e1" title="Read handler takes parameters. ">Handler::f_read_param</a>, then any read handler will accept parameters.</p>
<p>When the handler is triggered, Click will call <em>callback</em>(operation, data, <em>e</em>, h, errh), where:</p>
<ul>
<li>
"operation" is <a class="el" href="class_handler.html#ac08417becc781346bef93d6dd440bc55a53839db78e8b48bd46beb3d8cff3f2d3" title="Handler supports read operations. ">Handler::f_read</a> or <a class="el" href="class_handler.html#ac08417becc781346bef93d6dd440bc55affb8316da8ea607553b43f123b3d6403" title="Handler supports write operations. ">Handler::f_write</a>; </li>
<li>
"data" is the handler data (empty for reads without parameters); </li>
<li>
"h" is a pointer to a <a class="el" href="class_handler.html" title="Represents a router&#39;s handlers. ">Handler</a> object; and </li>
<li>
"errh" is an <a class="el" href="class_error_handler.html" title="Error reporting class. ">ErrorHandler</a>. </li>
</ul>
<p>Any previous handlers with the same name and element are replaced.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_router.html#a54040e26f6062f5e1fb109bbaef58f57" title="Add an e.hname read handler. ">add_read_handler()</a>, <a class="el" href="class_router.html#aa24506500f646dcc8ea6803807814a64" title="Add an e.hname write handler. ">add_write_handler()</a>, <a class="el" href="class_router.html#a837d04d19614b41dac07c97f547e356d" title="Change the e.hname handler&#39;s flags. ">set_handler_flags()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a837d04d19614b41dac07c97f547e356d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Router::set_handler_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>hname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>set_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>clear_flags</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the <em>e</em>.<em>hname</em> handler's flags. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>element, if any </td></tr>
    <tr><td class="paramname">hname</td><td>handler name </td></tr>
    <tr><td class="paramname">set_flags</td><td>flags to set (<a class="el" href="class_handler.html#a007e8050210701c7fa4ce3b087d4f8fe" title="Return this handler&#39;s flags. ">Handler::flags()</a>) </td></tr>
    <tr><td class="paramname">clear_flags</td><td>flags to clear (<a class="el" href="class_handler.html#a007e8050210701c7fa4ce3b087d4f8fe" title="Return this handler&#39;s flags. ">Handler::flags()</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the handler existed, -1 otherwise</dd></dl>
<p>Changes the handler flags for the handler named <em>hname</em> on element <em>e</em>. If <em>e</em> is NULL or equal to some <a class="el" href="class_router.html#a6839bfb0b5a2f27b4b3e41e2fa3fb51c" title="Returns this router&#39;s root element. ">root_element()</a>, then changes a global handler. The handler's flags are changed by clearing the <em>clear_flags</em> and then setting the <em>set_flags</em>, except that the special flags (<a class="el" href="class_handler.html#ac08417becc781346bef93d6dd440bc55a3b52e5951b2e37a89f4833dab3e17774" title="These flags may not be set by Router::set_handler_flags(). ">Handler::f_special</a>) are unchanged.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_router.html#a54040e26f6062f5e1fb109bbaef58f57" title="Add an e.hname read handler. ">add_read_handler()</a>, <a class="el" href="class_router.html#aa24506500f646dcc8ea6803807814a64" title="Add an e.hname write handler. ">add_write_handler()</a>, <a class="el" href="class_router.html#ac219c8731ddb3dbbb08d2724c32e32ec" title="Add a comprehensive e.hname handler. ">set_handler()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4f27682925a15a07acf9694cb6271e2a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Router::hindex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>hname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the handler index for element <em>e's</em> handler named <em>hname</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>element, if any </td></tr>
    <tr><td class="paramname">hname</td><td>handler name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the handler index, or -1 if no such handler exists</dd></dl>
<p>Searches for element <em>e's</em> handler named <em>hname</em>. Returns -1 if no such handler exists. If <em>e</em> is NULL or equal to some <a class="el" href="class_router.html#a6839bfb0b5a2f27b4b3e41e2fa3fb51c" title="Returns this router&#39;s root element. ">root_element()</a>, then this function searches for a global handler named <em>hname</em>.</p>
<p>The returned integer is a handler index, which is a number that identifies the handler. An integer &gt;= FIRST_GLOBAL_HANDLER corresponds to a global handler. </p>

</div>
</div>
<a class="anchor" id="a6813a52aee1c2f3f937cb80706794172"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_handler.html">Handler</a> * Router::handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_router.html">Router</a> *&#160;</td>
          <td class="paramname"><em>router</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>hindex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <em>router's</em> handler with index <em>hindex</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">router</td><td>the router </td></tr>
    <tr><td class="paramname">hindex</td><td>handler index (<a class="el" href="class_router.html#a4f27682925a15a07acf9694cb6271e2a" title="Return the handler index for element e&#39;s handler named hname. ">Router::hindex()</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_handler.html" title="Represents a router&#39;s handlers. ">Handler</a>, or null if no such handler exists</dd></dl>
<p>Returns the <a class="el" href="class_handler.html" title="Represents a router&#39;s handlers. ">Handler</a> object on <em>router</em> with handler index <em>hindex</em>. If <em>hindex</em> &gt;= FIRST_GLOBAL_HANDLER, then returns a global handler. If <em>hindex</em> is &lt; 0 or corresponds to no existing handler, returns null.</p>
<p>The return <a class="el" href="class_handler.html" title="Represents a router&#39;s handlers. ">Handler</a> pointer remains valid until the named handler is changed in some way (<a class="el" href="class_router.html#a54040e26f6062f5e1fb109bbaef58f57" title="Add an e.hname read handler. ">add_read_handler()</a>, <a class="el" href="class_router.html#aa24506500f646dcc8ea6803807814a64" title="Add an e.hname write handler. ">add_write_handler()</a>, <a class="el" href="class_router.html#ac219c8731ddb3dbbb08d2724c32e32ec" title="Add a comprehensive e.hname handler. ">set_handler()</a>, or <a class="el" href="class_router.html#a837d04d19614b41dac07c97f547e356d" title="Change the e.hname handler&#39;s flags. ">set_handler_flags()</a>). </p>

</div>
</div>
<a class="anchor" id="ad06da840971bee4e4fc7efbb19e33193"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Router::element_hindexes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector.html">Vector</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the handler indexes for element <em>e's</em> handlers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>element, if any </td></tr>
    <tr><td class="paramname">result</td><td>collector for handler indexes</td></tr>
  </table>
  </dd>
</dl>
<p>Iterates over all element <em>e's</em> handlers, and appends their handler indexes to <em>result</em>. If <em>e</em> is NULL or equal to some <a class="el" href="class_router.html#a6839bfb0b5a2f27b4b3e41e2fa3fb51c" title="Returns this router&#39;s root element. ">root_element()</a>, then iterates over the global handlers. </p>

</div>
</div>
<a class="anchor" id="ac0425632f3adf69c9b5924e343b21a3b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_string.html">String</a> Router::configuration_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the router's initial configuration string. </p>
<p>never</p>
<dl class="section return"><dt>Returns</dt><dd>The configuration string specified to the constructor. </dd></dl>

</div>
</div>
<a class="anchor" id="a12d319d8ff350e69bb6c3a3e821f932b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Router::unparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_string_accum.html">StringAccum</a> &amp;&#160;</td>
          <td class="paramname"><em>sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>indent</em> = <code><a class="el" href="class_string.html">String</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unparse this router into <em>sa</em>. </p>
<p>Calls <a class="el" href="class_router.html#a2f753297208b3af535e08accac55c7c7" title="Unparse the router&#39;s requirements into sa. ">unparse_requirements()</a>, <a class="el" href="class_router.html#abdc347bc64f631f3d7c4f4efb59abb20" title="Unparse declarations of the router&#39;s elements into sa. ">unparse_declarations()</a>, and <a class="el" href="class_router.html#a1dc81821c5541fb998d0ef072e2cb1ea" title="Unparse the router&#39;s connections into sa. ">unparse_connections()</a>, in that order. Each line is prefixed by <em>indent</em>. </p>

</div>
</div>
<a class="anchor" id="a2f753297208b3af535e08accac55c7c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Router::unparse_requirements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_string_accum.html">StringAccum</a> &amp;&#160;</td>
          <td class="paramname"><em>sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>indent</em> = <code><a class="el" href="class_string.html">String</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unparse the router's requirements into <em>sa</em>. </p>
<p>neverAppends at most one require() statement to <em>sa</em>. </p>

</div>
</div>
<a class="anchor" id="abdc347bc64f631f3d7c4f4efb59abb20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Router::unparse_declarations </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_string_accum.html">StringAccum</a> &amp;&#160;</td>
          <td class="paramname"><em>sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>indent</em> = <code><a class="el" href="class_string.html">String</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unparse declarations of the router's elements into <em>sa</em>. </p>
<p>Appends this router's elements' declarations to <em>sa</em>. If the router is initialized, then each element's configuration string is found by <a class="el" href="class_element.html#a4c909e3f64f1104e0c70a5acc53166a0" title="Return the element&#39;s current configuration string. ">Element::configuration()</a>, which might include post-initialization changes. </p>

</div>
</div>
<a class="anchor" id="a1dc81821c5541fb998d0ef072e2cb1ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Router::unparse_connections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_string_accum.html">StringAccum</a> &amp;&#160;</td>
          <td class="paramname"><em>sa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>indent</em> = <code><a class="el" href="class_string.html">String</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unparse the router's connections into <em>sa</em>. </p>
<p>Appends this router's connections to <em>sa</em> in parseable format. </p>

</div>
</div>
<a class="anchor" id="a89bfd2f95d3683cf3b51b97c9d3ee08f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_string.html">String</a> Router::element_ports_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a string representing <em>e's</em> ports. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>element</td></tr>
  </table>
  </dd>
</dl>
<p>The returned string is suitable for an element's <code>ports</code> handler. It lists the input ports, then the output ports. For example:</p>
<pre>
1 input
push~   -       InfiniteSource@1 [0], InfiniteSource@4 [0]
1 output
push~   -       [0] Align@3
</pre><p>In the port lines, the first column describes the processing type (a tilde suffix represents an agnostic port); the second column lists any packet statistics available; and the third column lists other ports that are connected to this port. </p>

</div>
</div>
<a class="anchor" id="ab7f39faf9ebc7c3440c9c45bd8f7147e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Router::use </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Increment the router's reference count. </p>
<p>Routers are reference counted objects. A <a class="el" href="class_router.html" title="A router configuration. ">Router</a> is created with one reference, which is held by its Master object. Normally the <a class="el" href="class_router.html" title="A router configuration. ">Router</a> and all its elements will be deleted when the Master drops this reference, but you can preserve the <a class="el" href="class_router.html" title="A router configuration. ">Router</a> for longer by adding a reference yourself. </p>

</div>
</div>
<a class="anchor" id="a420a7cbbff6e74b0db2379a83e387b22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Router::unuse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decrement the router's reference count. </p>
<p>Destroys the router if the reference count decrements to zero. </p>

</div>
</div>
<a class="anchor" id="a0a8ff9d773631cd072c2571ec39f568c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_router.html">Router</a> * Router::hotswap_router </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the currently-installed router this router will eventually replace. </p>
<p>This function is only meaningful during a router's initialization. If this router was installed with the hotswap option, then <a class="el" href="class_router.html#a0a8ff9d773631cd072c2571ec39f568c" title="Returns the currently-installed router this router will eventually replace. ">hotswap_router()</a> will return the currently-installed router that this router will eventually replace (assuming error-free initialization). Otherwise, <a class="el" href="class_router.html#a0a8ff9d773631cd072c2571ec39f568c" title="Returns the currently-installed router this router will eventually replace. ">hotswap_router()</a> will return 0. </p>

</div>
</div>
<a class="anchor" id="ad43fd6bdbe237dc480ed0e1fd419e313"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Router::new_notifier_signal </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_notifier_signal.html">NotifierSignal</a> &amp;&#160;</td>
          <td class="paramname"><em>signal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new basic signal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">name</td><td>signal name </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">signal</td><td>set to new signal</td></tr>
  </table>
  </dd>
</dl>
<p>Creates a new basic <a class="el" href="class_notifier_signal.html" title="An activity signal. ">NotifierSignal</a> and stores it in <em>signal</em>. The signal is initially active.</p>
<dl class="section note"><dt>Note</dt><dd>Users will not generally call this function directly; <a class="el" href="class_notifier.html#ab7ef31b00ff3ae11bf2c512bf1827eb0" title="Initialize the associated NotifierSignal, if necessary. ">Notifier::initialize()</a> will call it as required.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;= 0 on success, &lt; 0 on failure </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_notifier_signal.html" title="An activity signal. ">NotifierSignal</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/click/<a class="el" href="router_8hh_source.html">router.hh</a></li>
<li>lib/router.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 15 2018 22:13:46 for Click by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
