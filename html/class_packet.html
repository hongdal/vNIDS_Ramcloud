<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Click: Packet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Click
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_packet-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Packet Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A network packet.  
 <a href="class_packet.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for Packet:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_packet.png" usemap="#Packet_map" alt=""/>
  <map id="Packet_map" name="Packet_map">
<area href="class_writable_packet.html" title="A network packet believed not to be shared. " alt="WritablePacket" shape="rect" coords="0,56,96,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:afc19739ae15ec3c890b3d61246f890aa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc19739ae15ec3c890b3d61246f890aa"></a>
typedef&#160;</td><td class="memItemRight" valign="bottom"><b>typeof</b> (((struct sk_buff *) 0) -&gt;<a class="el" href="class_packet.html#a7a46d73a893a368c39f62e2c1a2b79d4">mac_header</a>) mac_header_type</td></tr>
<tr class="separator:afc19739ae15ec3c890b3d61246f890aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae904744051e4fdc727b7402cc0561d00"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae904744051e4fdc727b7402cc0561d00"></a>
typedef&#160;</td><td class="memItemRight" valign="bottom"><b>typeof</b> (((struct sk_buff *) 0) -&gt;<a class="el" href="class_packet.html#afd294846a5129344ed35071c277b5ceb">network_header</a>) network_header_type</td></tr>
<tr class="separator:ae904744051e4fdc727b7402cc0561d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c500e24d20cb4eb9b78ae8270ca862"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13c500e24d20cb4eb9b78ae8270ca862"></a>
typedef&#160;</td><td class="memItemRight" valign="bottom"><b>typeof</b> (((struct sk_buff *) 0) -&gt;<a class="el" href="class_packet.html#aab05b59f5c8e4bbea2ffa8d6d1ad31e7">transport_header</a>) transport_header_type</td></tr>
<tr class="separator:a13c500e24d20cb4eb9b78ae8270ca862"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Data</h2></td></tr>
<tr class="memitem:a7f1a7f4452ceaddcae7fe82b072b5b71"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="class_packet.html#a7f1a7f4452ceaddcae7fe82b072b5b71a1e08f43e330fdd6cc410e3a4e8a81ea8">default_headroom</a> = 28, 
<a class="el" href="class_packet.html#a7f1a7f4452ceaddcae7fe82b072b5b71ae12286b32f83242acb34ee02dab24802">min_buffer_length</a> = 64
 }</td></tr>
<tr class="separator:a7f1a7f4452ceaddcae7fe82b072b5b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e39e4be61632b06521450f7a926ea61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e39e4be61632b06521450f7a926ea61"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>buffer_destructor_type</b> )(unsigned char *buf, size_t sz, void *argument)</td></tr>
<tr class="separator:a0e39e4be61632b06521450f7a926ea61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7e476f1fbd63881c077cf4941b0277"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_writable_packet.html">WritablePacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a3f7e476f1fbd63881c077cf4941b0277">make</a> (uint32_t <a class="el" href="class_packet.html#a1c32d409a895a910bf053e31553dc5a7">headroom</a>, const void *<a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b">data</a>, uint32_t <a class="el" href="class_packet.html#a70d251ee2af3e1acacbd5026e264ca34">length</a>, uint32_t <a class="el" href="class_packet.html#ae5a9987122def9cf9e3973173cb8df87">tailroom</a>)</td></tr>
<tr class="memdesc:a3f7e476f1fbd63881c077cf4941b0277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a new packet.  <a href="#a3f7e476f1fbd63881c077cf4941b0277">More...</a><br/></td></tr>
<tr class="separator:a3f7e476f1fbd63881c077cf4941b0277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5488fd79cc716d6b65cc70a91fd6c47b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_writable_packet.html">WritablePacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a5488fd79cc716d6b65cc70a91fd6c47b">make</a> (const void *<a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b">data</a>, uint32_t <a class="el" href="class_packet.html#a70d251ee2af3e1acacbd5026e264ca34">length</a>)</td></tr>
<tr class="memdesc:a5488fd79cc716d6b65cc70a91fd6c47b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a new packet.  <a href="#a5488fd79cc716d6b65cc70a91fd6c47b">More...</a><br/></td></tr>
<tr class="separator:a5488fd79cc716d6b65cc70a91fd6c47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ce2535324d0ffb0cd7d2511f4126ed"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_writable_packet.html">WritablePacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a76ce2535324d0ffb0cd7d2511f4126ed">make</a> (uint32_t <a class="el" href="class_packet.html#a70d251ee2af3e1acacbd5026e264ca34">length</a>)</td></tr>
<tr class="memdesc:a76ce2535324d0ffb0cd7d2511f4126ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a new packet.  <a href="#a76ce2535324d0ffb0cd7d2511f4126ed">More...</a><br/></td></tr>
<tr class="separator:a76ce2535324d0ffb0cd7d2511f4126ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a67b80511e3161349f6bdd040faf86"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a11a67b80511e3161349f6bdd040faf86">make</a> (struct sk_buff *skb)</td></tr>
<tr class="memdesc:a11a67b80511e3161349f6bdd040faf86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change an sk_buff into a <a class="el" href="class_packet.html" title="A network packet. ">Packet</a> (linuxmodule).  <a href="#a11a67b80511e3161349f6bdd040faf86">More...</a><br/></td></tr>
<tr class="separator:a11a67b80511e3161349f6bdd040faf86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e3a7be2d7dc76e83fa5baff36c5fce"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_writable_packet.html">WritablePacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a40e3a7be2d7dc76e83fa5baff36c5fce">make</a> (unsigned char *<a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b">data</a>, uint32_t <a class="el" href="class_packet.html#a70d251ee2af3e1acacbd5026e264ca34">length</a>, buffer_destructor_type buffer_destructor, void *argument=(void *) 0, int <a class="el" href="class_packet.html#a1c32d409a895a910bf053e31553dc5a7">headroom</a>=0, int <a class="el" href="class_packet.html#ae5a9987122def9cf9e3973173cb8df87">tailroom</a>=0)</td></tr>
<tr class="memdesc:a40e3a7be2d7dc76e83fa5baff36c5fce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a new packet (userlevel).  <a href="#a40e3a7be2d7dc76e83fa5baff36c5fce">More...</a><br/></td></tr>
<tr class="separator:a40e3a7be2d7dc76e83fa5baff36c5fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f54c89014964296ee1d01c440c952ad"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f54c89014964296ee1d01c440c952ad"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>static_cleanup</b> ()</td></tr>
<tr class="separator:a0f54c89014964296ee1d01c440c952ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c95c6ebd45e8c7d1b85b22b27b29118"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a4c95c6ebd45e8c7d1b85b22b27b29118">kill</a> ()</td></tr>
<tr class="memdesc:a4c95c6ebd45e8c7d1b85b22b27b29118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete this packet.  <a href="#a4c95c6ebd45e8c7d1b85b22b27b29118">More...</a><br/></td></tr>
<tr class="separator:a4c95c6ebd45e8c7d1b85b22b27b29118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba191909862d94edefb19d4b5f548cf7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#aba191909862d94edefb19d4b5f548cf7">shared</a> () const </td></tr>
<tr class="memdesc:aba191909862d94edefb19d4b5f548cf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether this packet's data is shared.  <a href="#aba191909862d94edefb19d4b5f548cf7">More...</a><br/></td></tr>
<tr class="separator:aba191909862d94edefb19d4b5f548cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa274049bd162e38785c514fa512c44e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#aa274049bd162e38785c514fa512c44e8">clone</a> ()</td></tr>
<tr class="memdesc:aa274049bd162e38785c514fa512c44e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a clone of this packet.  <a href="#aa274049bd162e38785c514fa512c44e8">More...</a><br/></td></tr>
<tr class="separator:aa274049bd162e38785c514fa512c44e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fcf41ec1dd9ad25d59776d1bab983a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_writable_packet.html">WritablePacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a6fcf41ec1dd9ad25d59776d1bab983a3">uniqueify</a> ()</td></tr>
<tr class="memdesc:a6fcf41ec1dd9ad25d59776d1bab983a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an unshared packet containing this packet's data.  <a href="#a6fcf41ec1dd9ad25d59776d1bab983a3">More...</a><br/></td></tr>
<tr class="separator:a6fcf41ec1dd9ad25d59776d1bab983a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547fb52b84a4e9a74bd1f4599665098b"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b">data</a> () const </td></tr>
<tr class="memdesc:a547fb52b84a4e9a74bd1f4599665098b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet's data pointer.  <a href="#a547fb52b84a4e9a74bd1f4599665098b">More...</a><br/></td></tr>
<tr class="separator:a547fb52b84a4e9a74bd1f4599665098b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e09d33c102240db56b2a43f30c1886d"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a0e09d33c102240db56b2a43f30c1886d">end_data</a> () const </td></tr>
<tr class="memdesc:a0e09d33c102240db56b2a43f30c1886d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet's end data pointer.  <a href="#a0e09d33c102240db56b2a43f30c1886d">More...</a><br/></td></tr>
<tr class="separator:a0e09d33c102240db56b2a43f30c1886d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70d251ee2af3e1acacbd5026e264ca34"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a70d251ee2af3e1acacbd5026e264ca34">length</a> () const </td></tr>
<tr class="memdesc:a70d251ee2af3e1acacbd5026e264ca34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet's length.  <a href="#a70d251ee2af3e1acacbd5026e264ca34">More...</a><br/></td></tr>
<tr class="separator:a70d251ee2af3e1acacbd5026e264ca34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c32d409a895a910bf053e31553dc5a7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a1c32d409a895a910bf053e31553dc5a7">headroom</a> () const </td></tr>
<tr class="memdesc:a1c32d409a895a910bf053e31553dc5a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet's headroom.  <a href="#a1c32d409a895a910bf053e31553dc5a7">More...</a><br/></td></tr>
<tr class="separator:a1c32d409a895a910bf053e31553dc5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a9987122def9cf9e3973173cb8df87"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#ae5a9987122def9cf9e3973173cb8df87">tailroom</a> () const </td></tr>
<tr class="memdesc:ae5a9987122def9cf9e3973173cb8df87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet's tailroom.  <a href="#ae5a9987122def9cf9e3973173cb8df87">More...</a><br/></td></tr>
<tr class="separator:ae5a9987122def9cf9e3973173cb8df87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe89b8828541d410cb31ee2145e7a8c"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#adbe89b8828541d410cb31ee2145e7a8c">buffer</a> () const </td></tr>
<tr class="memdesc:adbe89b8828541d410cb31ee2145e7a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the packet's data buffer.  <a href="#adbe89b8828541d410cb31ee2145e7a8c">More...</a><br/></td></tr>
<tr class="separator:adbe89b8828541d410cb31ee2145e7a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b4556d1300bb7a95e23b6657294714d"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a7b4556d1300bb7a95e23b6657294714d">end_buffer</a> () const </td></tr>
<tr class="memdesc:a7b4556d1300bb7a95e23b6657294714d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet's end data buffer pointer.  <a href="#a7b4556d1300bb7a95e23b6657294714d">More...</a><br/></td></tr>
<tr class="separator:a7b4556d1300bb7a95e23b6657294714d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb06d9a3645eb12d16e04008aead92f6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#afb06d9a3645eb12d16e04008aead92f6">buffer_length</a> () const </td></tr>
<tr class="memdesc:afb06d9a3645eb12d16e04008aead92f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet's buffer length.  <a href="#afb06d9a3645eb12d16e04008aead92f6">More...</a><br/></td></tr>
<tr class="separator:afb06d9a3645eb12d16e04008aead92f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9154d3999a227752f550a4e8ae5ceac5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9154d3999a227752f550a4e8ae5ceac5"></a>
struct sk_buff *&#160;</td><td class="memItemRight" valign="bottom"><b>skb</b> ()</td></tr>
<tr class="separator:a9154d3999a227752f550a4e8ae5ceac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111d5e34827a1183f5594b5bb79020e9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a111d5e34827a1183f5594b5bb79020e9"></a>
const struct sk_buff *&#160;</td><td class="memItemRight" valign="bottom"><b>skb</b> () const </td></tr>
<tr class="separator:a111d5e34827a1183f5594b5bb79020e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f07d2050c0eac6625e271c6d3398ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_writable_packet.html">WritablePacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a65f07d2050c0eac6625e271c6d3398ea">push</a> (uint32_t len)</td></tr>
<tr class="memdesc:a65f07d2050c0eac6625e271c6d3398ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add space for a header before the packet.  <a href="#a65f07d2050c0eac6625e271c6d3398ea">More...</a><br/></td></tr>
<tr class="separator:a65f07d2050c0eac6625e271c6d3398ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d9b58effdf1a3a52baa3791782c466"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_writable_packet.html">WritablePacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a48d9b58effdf1a3a52baa3791782c466">push_mac_header</a> (uint32_t len)</td></tr>
<tr class="memdesc:a48d9b58effdf1a3a52baa3791782c466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add space for a MAC header before the packet.  <a href="#a48d9b58effdf1a3a52baa3791782c466">More...</a><br/></td></tr>
<tr class="separator:a48d9b58effdf1a3a52baa3791782c466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5953d4a49ce5f919eb6e9f46b7de25ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a5953d4a49ce5f919eb6e9f46b7de25ff">nonunique_push</a> (uint32_t len)</td></tr>
<tr class="memdesc:a5953d4a49ce5f919eb6e9f46b7de25ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add space for a header before the packet.  <a href="#a5953d4a49ce5f919eb6e9f46b7de25ff">More...</a><br/></td></tr>
<tr class="separator:a5953d4a49ce5f919eb6e9f46b7de25ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f817fb5d15980cc1d5bb27e851e85f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a54f817fb5d15980cc1d5bb27e851e85f">pull</a> (uint32_t len)</td></tr>
<tr class="memdesc:a54f817fb5d15980cc1d5bb27e851e85f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a header from the front of the packet.  <a href="#a54f817fb5d15980cc1d5bb27e851e85f">More...</a><br/></td></tr>
<tr class="separator:a54f817fb5d15980cc1d5bb27e851e85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d977927daa81b1b26607ebd4d3dde6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_writable_packet.html">WritablePacket</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a2d977927daa81b1b26607ebd4d3dde6c">put</a> (uint32_t len)</td></tr>
<tr class="memdesc:a2d977927daa81b1b26607ebd4d3dde6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add space for data after the packet.  <a href="#a2d977927daa81b1b26607ebd4d3dde6c">More...</a><br/></td></tr>
<tr class="separator:a2d977927daa81b1b26607ebd4d3dde6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd9c1423e78e95ccba6fb5cbc27095a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#adbd9c1423e78e95ccba6fb5cbc27095a">nonunique_put</a> (uint32_t len)</td></tr>
<tr class="memdesc:adbd9c1423e78e95ccba6fb5cbc27095a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add space for data after the packet.  <a href="#adbd9c1423e78e95ccba6fb5cbc27095a">More...</a><br/></td></tr>
<tr class="separator:adbd9c1423e78e95ccba6fb5cbc27095a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdff7a45566ae198c9ed246707d5317f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#abdff7a45566ae198c9ed246707d5317f">take</a> (uint32_t len)</td></tr>
<tr class="memdesc:abdff7a45566ae198c9ed246707d5317f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove space from the end of the packet.  <a href="#abdff7a45566ae198c9ed246707d5317f">More...</a><br/></td></tr>
<tr class="separator:abdff7a45566ae198c9ed246707d5317f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d4a911a16c615599137bea2f56318f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a71d4a911a16c615599137bea2f56318f">shift_data</a> (int offset, bool free_on_failure=true)</td></tr>
<tr class="memdesc:a71d4a911a16c615599137bea2f56318f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift packet data within the data buffer.  <a href="#a71d4a911a16c615599137bea2f56318f">More...</a><br/></td></tr>
<tr class="separator:a71d4a911a16c615599137bea2f56318f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b816dbdc37314f566917a840c2bdf29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a0b816dbdc37314f566917a840c2bdf29">shrink_data</a> (const unsigned char *<a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b">data</a>, uint32_t <a class="el" href="class_packet.html#a70d251ee2af3e1acacbd5026e264ca34">length</a>)</td></tr>
<tr class="memdesc:a0b816dbdc37314f566917a840c2bdf29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrink the packet's data.  <a href="#a0b816dbdc37314f566917a840c2bdf29">More...</a><br/></td></tr>
<tr class="separator:a0b816dbdc37314f566917a840c2bdf29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823d5f220d1c6bf58aff94a22a6acde7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a823d5f220d1c6bf58aff94a22a6acde7">change_headroom_and_length</a> (uint32_t <a class="el" href="class_packet.html#a1c32d409a895a910bf053e31553dc5a7">headroom</a>, uint32_t <a class="el" href="class_packet.html#a70d251ee2af3e1acacbd5026e264ca34">length</a>)</td></tr>
<tr class="memdesc:a823d5f220d1c6bf58aff94a22a6acde7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shift the packet's data view to a different part of its buffer.  <a href="#a823d5f220d1c6bf58aff94a22a6acde7">More...</a><br/></td></tr>
<tr class="separator:a823d5f220d1c6bf58aff94a22a6acde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc493cf317d2bbbcdb891b124068d9cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#adc493cf317d2bbbcdb891b124068d9cc">copy</a> (<a class="el" href="class_packet.html">Packet</a> *p, int <a class="el" href="class_packet.html#a1c32d409a895a910bf053e31553dc5a7">headroom</a>=0)</td></tr>
<tr class="memdesc:adc493cf317d2bbbcdb891b124068d9cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the content and annotations of another packet (userlevel).  <a href="#adc493cf317d2bbbcdb891b124068d9cc">More...</a><br/></td></tr>
<tr class="separator:adc493cf317d2bbbcdb891b124068d9cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Header Pointers</h2></td></tr>
<tr class="memitem:a5c2586fa612b3892fc0e2a7616285cdf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a5c2586fa612b3892fc0e2a7616285cdf">has_mac_header</a> () const </td></tr>
<tr class="memdesc:a5c2586fa612b3892fc0e2a7616285cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff the packet's MAC header pointer is set.  <a href="#a5c2586fa612b3892fc0e2a7616285cdf">More...</a><br/></td></tr>
<tr class="separator:a5c2586fa612b3892fc0e2a7616285cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a46d73a893a368c39f62e2c1a2b79d4"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a7a46d73a893a368c39f62e2c1a2b79d4">mac_header</a> () const </td></tr>
<tr class="memdesc:a7a46d73a893a368c39f62e2c1a2b79d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet's MAC header pointer.  <a href="#a7a46d73a893a368c39f62e2c1a2b79d4">More...</a><br/></td></tr>
<tr class="separator:a7a46d73a893a368c39f62e2c1a2b79d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d9ef137618c8d8ff0b3e451622df4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a16d9ef137618c8d8ff0b3e451622df4e">mac_header_offset</a> () const </td></tr>
<tr class="memdesc:a16d9ef137618c8d8ff0b3e451622df4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the offset from the packet data to the MAC header.  <a href="#a16d9ef137618c8d8ff0b3e451622df4e">More...</a><br/></td></tr>
<tr class="separator:a16d9ef137618c8d8ff0b3e451622df4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87805cecf70e93f7a12faf67996825e2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a87805cecf70e93f7a12faf67996825e2">mac_header_length</a> () const </td></tr>
<tr class="memdesc:a87805cecf70e93f7a12faf67996825e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the MAC header length.  <a href="#a87805cecf70e93f7a12faf67996825e2">More...</a><br/></td></tr>
<tr class="separator:a87805cecf70e93f7a12faf67996825e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5274ed03ef428275f8b273600d7ee50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#ae5274ed03ef428275f8b273600d7ee50">mac_length</a> () const </td></tr>
<tr class="memdesc:ae5274ed03ef428275f8b273600d7ee50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet's length starting from its MAC header pointer.  <a href="#ae5274ed03ef428275f8b273600d7ee50">More...</a><br/></td></tr>
<tr class="separator:ae5274ed03ef428275f8b273600d7ee50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228aa94d61f826f5020917375d39d05d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a228aa94d61f826f5020917375d39d05d">set_mac_header</a> (const unsigned char *p)</td></tr>
<tr class="memdesc:a228aa94d61f826f5020917375d39d05d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the MAC header pointer.  <a href="#a228aa94d61f826f5020917375d39d05d">More...</a><br/></td></tr>
<tr class="separator:a228aa94d61f826f5020917375d39d05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e157394f26c42592326a260ed71b3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#ae5e157394f26c42592326a260ed71b3c">set_mac_header</a> (const unsigned char *p, uint32_t len)</td></tr>
<tr class="memdesc:ae5e157394f26c42592326a260ed71b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the MAC and network header pointers.  <a href="#ae5e157394f26c42592326a260ed71b3c">More...</a><br/></td></tr>
<tr class="separator:ae5e157394f26c42592326a260ed71b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42131142404795b50a9380ef64a2f52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#ac42131142404795b50a9380ef64a2f52">clear_mac_header</a> ()</td></tr>
<tr class="memdesc:ac42131142404795b50a9380ef64a2f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unset the MAC header pointer.  <a href="#ac42131142404795b50a9380ef64a2f52">More...</a><br/></td></tr>
<tr class="separator:ac42131142404795b50a9380ef64a2f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5062b798be9675617c84c0378a5922"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a2d5062b798be9675617c84c0378a5922">has_network_header</a> () const </td></tr>
<tr class="memdesc:a2d5062b798be9675617c84c0378a5922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff the packet's network header pointer is set.  <a href="#a2d5062b798be9675617c84c0378a5922">More...</a><br/></td></tr>
<tr class="separator:a2d5062b798be9675617c84c0378a5922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd294846a5129344ed35071c277b5ceb"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#afd294846a5129344ed35071c277b5ceb">network_header</a> () const </td></tr>
<tr class="memdesc:afd294846a5129344ed35071c277b5ceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet's network header pointer.  <a href="#afd294846a5129344ed35071c277b5ceb">More...</a><br/></td></tr>
<tr class="separator:afd294846a5129344ed35071c277b5ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9daaf4f69b8091b52520bae57a9203b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a9daaf4f69b8091b52520bae57a9203b8">network_header_offset</a> () const </td></tr>
<tr class="memdesc:a9daaf4f69b8091b52520bae57a9203b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the offset from the packet data to the network header.  <a href="#a9daaf4f69b8091b52520bae57a9203b8">More...</a><br/></td></tr>
<tr class="separator:a9daaf4f69b8091b52520bae57a9203b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4513c30a56c8519f59a65b33db9dea0e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a4513c30a56c8519f59a65b33db9dea0e">network_header_length</a> () const </td></tr>
<tr class="memdesc:a4513c30a56c8519f59a65b33db9dea0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the network header length.  <a href="#a4513c30a56c8519f59a65b33db9dea0e">More...</a><br/></td></tr>
<tr class="separator:a4513c30a56c8519f59a65b33db9dea0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d9b046094ac828fa5814ced48ab15e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a9d9b046094ac828fa5814ced48ab15e3">network_length</a> () const </td></tr>
<tr class="memdesc:a9d9b046094ac828fa5814ced48ab15e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet's length starting from its network header pointer.  <a href="#a9d9b046094ac828fa5814ced48ab15e3">More...</a><br/></td></tr>
<tr class="separator:a9d9b046094ac828fa5814ced48ab15e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccedb02f5578da3861441b82fd88016"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a8ccedb02f5578da3861441b82fd88016">set_network_header</a> (const unsigned char *p, uint32_t len)</td></tr>
<tr class="memdesc:a8ccedb02f5578da3861441b82fd88016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the network and transport header pointers.  <a href="#a8ccedb02f5578da3861441b82fd88016">More...</a><br/></td></tr>
<tr class="separator:a8ccedb02f5578da3861441b82fd88016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80231c68fa6df0368e7611c9da726296"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a80231c68fa6df0368e7611c9da726296">set_network_header_length</a> (uint32_t len)</td></tr>
<tr class="memdesc:a80231c68fa6df0368e7611c9da726296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the network header length.  <a href="#a80231c68fa6df0368e7611c9da726296">More...</a><br/></td></tr>
<tr class="separator:a80231c68fa6df0368e7611c9da726296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed60e9f27d01d4065d00ed50295338cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#aed60e9f27d01d4065d00ed50295338cc">clear_network_header</a> ()</td></tr>
<tr class="memdesc:aed60e9f27d01d4065d00ed50295338cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unset the network header pointer.  <a href="#aed60e9f27d01d4065d00ed50295338cc">More...</a><br/></td></tr>
<tr class="separator:aed60e9f27d01d4065d00ed50295338cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f74f71d6f729673744e71402980b4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a05f74f71d6f729673744e71402980b4f">has_transport_header</a> () const </td></tr>
<tr class="memdesc:a05f74f71d6f729673744e71402980b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff the packet's network header pointer is set.  <a href="#a05f74f71d6f729673744e71402980b4f">More...</a><br/></td></tr>
<tr class="separator:a05f74f71d6f729673744e71402980b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab05b59f5c8e4bbea2ffa8d6d1ad31e7"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#aab05b59f5c8e4bbea2ffa8d6d1ad31e7">transport_header</a> () const </td></tr>
<tr class="memdesc:aab05b59f5c8e4bbea2ffa8d6d1ad31e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet's transport header pointer.  <a href="#aab05b59f5c8e4bbea2ffa8d6d1ad31e7">More...</a><br/></td></tr>
<tr class="separator:aab05b59f5c8e4bbea2ffa8d6d1ad31e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955d3c26b868477e094c3eb3d46a0e7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a955d3c26b868477e094c3eb3d46a0e7d">transport_header_offset</a> () const </td></tr>
<tr class="memdesc:a955d3c26b868477e094c3eb3d46a0e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the offset from the packet data to the transport header.  <a href="#a955d3c26b868477e094c3eb3d46a0e7d">More...</a><br/></td></tr>
<tr class="separator:a955d3c26b868477e094c3eb3d46a0e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8574b7f2b5141dc8ec2d8372eb8f74d6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a8574b7f2b5141dc8ec2d8372eb8f74d6">transport_length</a> () const </td></tr>
<tr class="memdesc:a8574b7f2b5141dc8ec2d8372eb8f74d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet's length starting from its transport header pointer.  <a href="#a8574b7f2b5141dc8ec2d8372eb8f74d6">More...</a><br/></td></tr>
<tr class="separator:a8574b7f2b5141dc8ec2d8372eb8f74d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eebe7b89b411906d088926a90fbafa0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a0eebe7b89b411906d088926a90fbafa0">clear_transport_header</a> ()</td></tr>
<tr class="memdesc:a0eebe7b89b411906d088926a90fbafa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unset the transport header pointer.  <a href="#a0eebe7b89b411906d088926a90fbafa0">More...</a><br/></td></tr>
<tr class="separator:a0eebe7b89b411906d088926a90fbafa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63787c8b422b022b8724f78d7ac8da39"><td class="memItemLeft" align="right" valign="top">const click_ether *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a63787c8b422b022b8724f78d7ac8da39">ether_header</a> () const </td></tr>
<tr class="memdesc:a63787c8b422b022b8724f78d7ac8da39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet's MAC header pointer as Ethernet.  <a href="#a63787c8b422b022b8724f78d7ac8da39">More...</a><br/></td></tr>
<tr class="separator:a63787c8b422b022b8724f78d7ac8da39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76af9e95e57d5c3f728959d52a5a211f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a76af9e95e57d5c3f728959d52a5a211f">set_ether_header</a> (const click_ether *ethh)</td></tr>
<tr class="memdesc:a76af9e95e57d5c3f728959d52a5a211f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the MAC header pointer to an Ethernet header.  <a href="#a76af9e95e57d5c3f728959d52a5a211f">More...</a><br/></td></tr>
<tr class="separator:a76af9e95e57d5c3f728959d52a5a211f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021870cf51b52aa40f3861affa9a1357"><td class="memItemLeft" align="right" valign="top">const click_ip *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a021870cf51b52aa40f3861affa9a1357">ip_header</a> () const </td></tr>
<tr class="memdesc:a021870cf51b52aa40f3861affa9a1357"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet's network header pointer as IPv4.  <a href="#a021870cf51b52aa40f3861affa9a1357">More...</a><br/></td></tr>
<tr class="separator:a021870cf51b52aa40f3861affa9a1357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac386ae82a577f4bef622dcbc6d23915d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#ac386ae82a577f4bef622dcbc6d23915d">ip_header_offset</a> () const </td></tr>
<tr class="memdesc:ac386ae82a577f4bef622dcbc6d23915d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the offset from the packet data to the IP header.  <a href="#ac386ae82a577f4bef622dcbc6d23915d">More...</a><br/></td></tr>
<tr class="separator:ac386ae82a577f4bef622dcbc6d23915d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ee6106632e47fd37cc08c70f27a1a7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#ad1ee6106632e47fd37cc08c70f27a1a7">ip_header_length</a> () const </td></tr>
<tr class="memdesc:ad1ee6106632e47fd37cc08c70f27a1a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the IP header length.  <a href="#ad1ee6106632e47fd37cc08c70f27a1a7">More...</a><br/></td></tr>
<tr class="separator:ad1ee6106632e47fd37cc08c70f27a1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac533aeeadb580ba67dbc9c3e5394aecd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#ac533aeeadb580ba67dbc9c3e5394aecd">set_ip_header</a> (const click_ip *iph, uint32_t len)</td></tr>
<tr class="memdesc:ac533aeeadb580ba67dbc9c3e5394aecd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the network header pointer to an IPv4 header.  <a href="#ac533aeeadb580ba67dbc9c3e5394aecd">More...</a><br/></td></tr>
<tr class="separator:ac533aeeadb580ba67dbc9c3e5394aecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75902c66131a3b3a1433083bce457c8d"><td class="memItemLeft" align="right" valign="top">const click_ip6 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a75902c66131a3b3a1433083bce457c8d">ip6_header</a> () const </td></tr>
<tr class="memdesc:a75902c66131a3b3a1433083bce457c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet's network header pointer as IPv6.  <a href="#a75902c66131a3b3a1433083bce457c8d">More...</a><br/></td></tr>
<tr class="separator:a75902c66131a3b3a1433083bce457c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac602c7113bc503d2137e7fc2629c5020"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#ac602c7113bc503d2137e7fc2629c5020">ip6_header_offset</a> () const </td></tr>
<tr class="memdesc:ac602c7113bc503d2137e7fc2629c5020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the offset from the packet data to the IPv6 header.  <a href="#ac602c7113bc503d2137e7fc2629c5020">More...</a><br/></td></tr>
<tr class="separator:ac602c7113bc503d2137e7fc2629c5020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcdbc796e6348f0f489b68c8cd287cb"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#abbcdbc796e6348f0f489b68c8cd287cb">ip6_header_length</a> () const </td></tr>
<tr class="memdesc:abbcdbc796e6348f0f489b68c8cd287cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the IPv6 header length.  <a href="#abbcdbc796e6348f0f489b68c8cd287cb">More...</a><br/></td></tr>
<tr class="separator:abbcdbc796e6348f0f489b68c8cd287cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c16b5583c5e8011c631143d3ca92439"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a0c16b5583c5e8011c631143d3ca92439">set_ip6_header</a> (const click_ip6 *ip6h)</td></tr>
<tr class="memdesc:a0c16b5583c5e8011c631143d3ca92439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the network header pointer to an IPv6 header.  <a href="#a0c16b5583c5e8011c631143d3ca92439">More...</a><br/></td></tr>
<tr class="separator:a0c16b5583c5e8011c631143d3ca92439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885abc2d81b92d4c04779a6f8ff4db0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a885abc2d81b92d4c04779a6f8ff4db0e">set_ip6_header</a> (const click_ip6 *ip6h, uint32_t len)</td></tr>
<tr class="memdesc:a885abc2d81b92d4c04779a6f8ff4db0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the network header pointer to an IPv6 header.  <a href="#a885abc2d81b92d4c04779a6f8ff4db0e">More...</a><br/></td></tr>
<tr class="separator:a885abc2d81b92d4c04779a6f8ff4db0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2083716e975dffedeb68af28e9c98c"><td class="memItemLeft" align="right" valign="top">const click_icmp *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a9d2083716e975dffedeb68af28e9c98c">icmp_header</a> () const </td></tr>
<tr class="memdesc:a9d2083716e975dffedeb68af28e9c98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet's transport header pointer as ICMP.  <a href="#a9d2083716e975dffedeb68af28e9c98c">More...</a><br/></td></tr>
<tr class="separator:a9d2083716e975dffedeb68af28e9c98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c5a9e2050051a83959f6905d68d5099"><td class="memItemLeft" align="right" valign="top">const click_tcp *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a4c5a9e2050051a83959f6905d68d5099">tcp_header</a> () const </td></tr>
<tr class="memdesc:a4c5a9e2050051a83959f6905d68d5099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet's transport header pointer as TCP.  <a href="#a4c5a9e2050051a83959f6905d68d5099">More...</a><br/></td></tr>
<tr class="separator:a4c5a9e2050051a83959f6905d68d5099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f29ae68c1bd946ce43c3ffc625a296e"><td class="memItemLeft" align="right" valign="top">const click_udp *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a4f29ae68c1bd946ce43c3ffc625a296e">udp_header</a> () const </td></tr>
<tr class="memdesc:a4f29ae68c1bd946ce43c3ffc625a296e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet's transport header pointer as UDP.  <a href="#a4f29ae68c1bd946ce43c3ffc625a296e">More...</a><br/></td></tr>
<tr class="separator:a4f29ae68c1bd946ce43c3ffc625a296e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1236d9a4fa528c65bebf98c1fb1de5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structclick__dns.html">click_dns</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a7d1236d9a4fa528c65bebf98c1fb1de5">dns_header</a> () const </td></tr>
<tr class="memdesc:a7d1236d9a4fa528c65bebf98c1fb1de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet's dns header pointer as DNS.  <a href="#a7d1236d9a4fa528c65bebf98c1fb1de5">More...</a><br/></td></tr>
<tr class="separator:a7d1236d9a4fa528c65bebf98c1fb1de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Annotations</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp933e469cb306a0ea9faabd3e4235d3be"></a>never </p>
</td></tr>
<tr class="memitem:a9da06ca41f8744c66f57db271302fbbb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="class_packet.html#a9da06ca41f8744c66f57db271302fbbba37ffbe2ed8e612868890511c356dc4f7">anno_size</a> = 48
 }</td></tr>
<tr class="separator:a9da06ca41f8744c66f57db271302fbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d687a19a8f94b7625c57a809c9f65b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a99d687a19a8f94b7625c57a809c9f65b">PacketType</a> { <br/>
&#160;&#160;<a class="el" href="class_packet.html#a99d687a19a8f94b7625c57a809c9f65ba917357cae65d61b57f8e36b3bead7451">HOST</a> = 0, 
<a class="el" href="class_packet.html#a99d687a19a8f94b7625c57a809c9f65ba9c7a27245a5f68b25553cca5b2f9e507">BROADCAST</a> = 1, 
<a class="el" href="class_packet.html#a99d687a19a8f94b7625c57a809c9f65ba7628b46f4730f2cf71b0c94bd8fbcd44">MULTICAST</a> = 2, 
<a class="el" href="class_packet.html#a99d687a19a8f94b7625c57a809c9f65ba3daed014fd8bc428f9d9c057cef5f2cb">OTHERHOST</a> = 3, 
<br/>
&#160;&#160;<a class="el" href="class_packet.html#a99d687a19a8f94b7625c57a809c9f65ba4a4c2329032aadc304b3ada1e65f9a6e">OUTGOING</a> = 4, 
<b>LOOPBACK</b> = 5, 
<b>FASTROUTE</b> = 6
<br/>
 }</td></tr>
<tr class="memdesc:a99d687a19a8f94b7625c57a809c9f65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values for <a class="el" href="class_packet.html#ac56ee973f22d65c9a2c7b20df7de3035" title="Return the packet type annotation. ">packet_type_anno()</a>. Must agree with Linux's PACKET_ constants in &lt;linux/if_packet.h&gt;.  <a href="class_packet.html#a99d687a19a8f94b7625c57a809c9f65b">More...</a><br/></td></tr>
<tr class="separator:a99d687a19a8f94b7625c57a809c9f65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f9b33a31bdbe6b7d8cfee11bc3d8009"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>dst_ip_anno_offset</b> = 0, 
<b>dst_ip_anno_size</b> = 4, 
<b>dst_ip6_anno_offset</b> = 0, 
<b>dst_ip6_anno_size</b> = 16
 }</td></tr>
<tr class="separator:a8f9b33a31bdbe6b7d8cfee11bc3d8009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd060f963d8c4ef9dedad91af9f19841"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_timestamp.html">Timestamp</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#abd060f963d8c4ef9dedad91af9f19841">timestamp_anno</a> () const </td></tr>
<tr class="memdesc:abd060f963d8c4ef9dedad91af9f19841"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the timestamp annotation.  <a href="#abd060f963d8c4ef9dedad91af9f19841">More...</a><br/></td></tr>
<tr class="separator:abd060f963d8c4ef9dedad91af9f19841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6760687354019bab34761317f0f3fb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_timestamp.html">Timestamp</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#ab6760687354019bab34761317f0f3fb5">timestamp_anno</a> ()</td></tr>
<tr class="separator:ab6760687354019bab34761317f0f3fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50f64d25d2640626d1923bd40db2dde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#af50f64d25d2640626d1923bd40db2dde">set_timestamp_anno</a> (const <a class="el" href="class_timestamp.html">Timestamp</a> &amp;t)</td></tr>
<tr class="memdesc:af50f64d25d2640626d1923bd40db2dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the timestamp annotation.  <a href="#af50f64d25d2640626d1923bd40db2dde">More...</a><br/></td></tr>
<tr class="separator:af50f64d25d2640626d1923bd40db2dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f6ca54977ec5676e78d506c50f3a53"><td class="memItemLeft" align="right" valign="top">net_device *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#af1f6ca54977ec5676e78d506c50f3a53">device_anno</a> () const </td></tr>
<tr class="memdesc:af1f6ca54977ec5676e78d506c50f3a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the device annotation.  <a href="#af1f6ca54977ec5676e78d506c50f3a53">More...</a><br/></td></tr>
<tr class="separator:af1f6ca54977ec5676e78d506c50f3a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9086298fc1806d6b6194bf047c4e11a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a9086298fc1806d6b6194bf047c4e11a3">set_device_anno</a> (net_device *dev)</td></tr>
<tr class="memdesc:a9086298fc1806d6b6194bf047c4e11a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the device annotation.  <a href="#a9086298fc1806d6b6194bf047c4e11a3">More...</a><br/></td></tr>
<tr class="separator:a9086298fc1806d6b6194bf047c4e11a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac56ee973f22d65c9a2c7b20df7de3035"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_packet.html#a99d687a19a8f94b7625c57a809c9f65b">PacketType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#ac56ee973f22d65c9a2c7b20df7de3035">packet_type_anno</a> () const </td></tr>
<tr class="memdesc:ac56ee973f22d65c9a2c7b20df7de3035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the packet type annotation.  <a href="#ac56ee973f22d65c9a2c7b20df7de3035">More...</a><br/></td></tr>
<tr class="separator:ac56ee973f22d65c9a2c7b20df7de3035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ce6541f8c20d59c9967ef21202ebd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#ae7ce6541f8c20d59c9967ef21202ebd0">set_packet_type_anno</a> (<a class="el" href="class_packet.html#a99d687a19a8f94b7625c57a809c9f65b">PacketType</a> t)</td></tr>
<tr class="memdesc:ae7ce6541f8c20d59c9967ef21202ebd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the packet type annotation.  <a href="#ae7ce6541f8c20d59c9967ef21202ebd0">More...</a><br/></td></tr>
<tr class="separator:ae7ce6541f8c20d59c9967ef21202ebd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87cf4d128d13182b033c2ee24fb6672c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a87cf4d128d13182b033c2ee24fb6672c">next</a> () const </td></tr>
<tr class="memdesc:a87cf4d128d13182b033c2ee24fb6672c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next packet annotation.  <a href="#a87cf4d128d13182b033c2ee24fb6672c">More...</a><br/></td></tr>
<tr class="separator:a87cf4d128d13182b033c2ee24fb6672c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f936c442fa8a3fd3b4fc61d8974680"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_packet.html">Packet</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#af4f936c442fa8a3fd3b4fc61d8974680">next</a> ()</td></tr>
<tr class="separator:af4f936c442fa8a3fd3b4fc61d8974680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50653ef20efbbe7a6715e08bf76434bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a50653ef20efbbe7a6715e08bf76434bd">set_next</a> (<a class="el" href="class_packet.html">Packet</a> *p)</td></tr>
<tr class="memdesc:a50653ef20efbbe7a6715e08bf76434bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the next packet annotation.  <a href="#a50653ef20efbbe7a6715e08bf76434bd">More...</a><br/></td></tr>
<tr class="separator:a50653ef20efbbe7a6715e08bf76434bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6f958dc910af7a8ae22c562cd8bca5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_packet.html">Packet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a8e6f958dc910af7a8ae22c562cd8bca5">prev</a> () const </td></tr>
<tr class="memdesc:a8e6f958dc910af7a8ae22c562cd8bca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the previous packet annotation.  <a href="#a8e6f958dc910af7a8ae22c562cd8bca5">More...</a><br/></td></tr>
<tr class="separator:a8e6f958dc910af7a8ae22c562cd8bca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf786dbbceb56f99472bb8a81a728de8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_packet.html">Packet</a> *&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#abf786dbbceb56f99472bb8a81a728de8">prev</a> ()</td></tr>
<tr class="separator:abf786dbbceb56f99472bb8a81a728de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52b46102d7113e5555b6dc887fd3edf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#af52b46102d7113e5555b6dc887fd3edf">set_prev</a> (<a class="el" href="class_packet.html">Packet</a> *p)</td></tr>
<tr class="memdesc:af52b46102d7113e5555b6dc887fd3edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the previous packet annotation.  <a href="#af52b46102d7113e5555b6dc887fd3edf">More...</a><br/></td></tr>
<tr class="separator:af52b46102d7113e5555b6dc887fd3edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d4c6488d28abea4e14ea84b90be64a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_i_p_address.html">IPAddress</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#ab6d4c6488d28abea4e14ea84b90be64a">dst_ip_anno</a> () const </td></tr>
<tr class="memdesc:ab6d4c6488d28abea4e14ea84b90be64a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the destination IPv4 address annotation.  <a href="#ab6d4c6488d28abea4e14ea84b90be64a">More...</a><br/></td></tr>
<tr class="separator:ab6d4c6488d28abea4e14ea84b90be64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e0c2708bafb1cb661223867f2da34b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a3e0c2708bafb1cb661223867f2da34b7">set_dst_ip_anno</a> (<a class="el" href="class_i_p_address.html">IPAddress</a> addr)</td></tr>
<tr class="memdesc:a3e0c2708bafb1cb661223867f2da34b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the destination IPv4 address annotation.  <a href="#a3e0c2708bafb1cb661223867f2da34b7">More...</a><br/></td></tr>
<tr class="separator:a3e0c2708bafb1cb661223867f2da34b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb62ea68b33bfc7ccb23fef5c7a4bd7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a4bb62ea68b33bfc7ccb23fef5c7a4bd7">anno</a> ()</td></tr>
<tr class="memdesc:a4bb62ea68b33bfc7ccb23fef5c7a4bd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the annotation area.  <a href="#a4bb62ea68b33bfc7ccb23fef5c7a4bd7">More...</a><br/></td></tr>
<tr class="separator:a4bb62ea68b33bfc7ccb23fef5c7a4bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8cb59296235d8723f93f3ff89cd8cb"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a6c8cb59296235d8723f93f3ff89cd8cb">anno</a> () const </td></tr>
<tr class="separator:a6c8cb59296235d8723f93f3ff89cd8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f7f051482d565dd0f84e931d69958c"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a10f7f051482d565dd0f84e931d69958c">anno_u8</a> ()</td></tr>
<tr class="memdesc:a10f7f051482d565dd0f84e931d69958c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the annotation area as uint8_ts.  <a href="#a10f7f051482d565dd0f84e931d69958c">More...</a><br/></td></tr>
<tr class="separator:a10f7f051482d565dd0f84e931d69958c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502bc1b95701c478b180248a8a6fb9e4"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a502bc1b95701c478b180248a8a6fb9e4">anno_u8</a> () const </td></tr>
<tr class="memdesc:a502bc1b95701c478b180248a8a6fb9e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload  <a href="#a502bc1b95701c478b180248a8a6fb9e4">More...</a><br/></td></tr>
<tr class="separator:a502bc1b95701c478b180248a8a6fb9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91f01a28db1106cf6d8f7e331c70be8"><td class="memItemLeft" align="right" valign="top">uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#ad91f01a28db1106cf6d8f7e331c70be8">anno_u32</a> ()</td></tr>
<tr class="memdesc:ad91f01a28db1106cf6d8f7e331c70be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the annotation area as uint32_ts.  <a href="#ad91f01a28db1106cf6d8f7e331c70be8">More...</a><br/></td></tr>
<tr class="separator:ad91f01a28db1106cf6d8f7e331c70be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbd4be843f49b812edb9843ac0afa93"><td class="memItemLeft" align="right" valign="top">const uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a3cbd4be843f49b812edb9843ac0afa93">anno_u32</a> () const </td></tr>
<tr class="memdesc:a3cbd4be843f49b812edb9843ac0afa93"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload  <a href="#a3cbd4be843f49b812edb9843ac0afa93">More...</a><br/></td></tr>
<tr class="separator:a3cbd4be843f49b812edb9843ac0afa93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f79538338891d00db65d27fc694077"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#af5f79538338891d00db65d27fc694077">anno_u8</a> (int i) const </td></tr>
<tr class="memdesc:af5f79538338891d00db65d27fc694077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return annotation byte at offset <em>i</em>.  <a href="#af5f79538338891d00db65d27fc694077">More...</a><br/></td></tr>
<tr class="separator:af5f79538338891d00db65d27fc694077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7af380fd9ca70234b989cda231fb1dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#ac7af380fd9ca70234b989cda231fb1dc">set_anno_u8</a> (int i, uint8_t x)</td></tr>
<tr class="memdesc:ac7af380fd9ca70234b989cda231fb1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set annotation byte at offset <em>i</em>.  <a href="#ac7af380fd9ca70234b989cda231fb1dc">More...</a><br/></td></tr>
<tr class="separator:ac7af380fd9ca70234b989cda231fb1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc26f612c80e38d6b6b3a89948ce37d2"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#abc26f612c80e38d6b6b3a89948ce37d2">anno_u16</a> (int i) const </td></tr>
<tr class="memdesc:abc26f612c80e38d6b6b3a89948ce37d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 16-bit annotation at offset <em>i</em>.  <a href="#abc26f612c80e38d6b6b3a89948ce37d2">More...</a><br/></td></tr>
<tr class="separator:abc26f612c80e38d6b6b3a89948ce37d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d0258d9558db418ce435c77170402e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a12d0258d9558db418ce435c77170402e">set_anno_u16</a> (int i, uint16_t x)</td></tr>
<tr class="memdesc:a12d0258d9558db418ce435c77170402e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set 16-bit annotation at offset <em>i</em>.  <a href="#a12d0258d9558db418ce435c77170402e">More...</a><br/></td></tr>
<tr class="separator:a12d0258d9558db418ce435c77170402e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717a2e1fdf5402ffa6f811d5f5477248"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a717a2e1fdf5402ffa6f811d5f5477248">anno_s16</a> (int i) const </td></tr>
<tr class="memdesc:a717a2e1fdf5402ffa6f811d5f5477248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 16-bit annotation at offset <em>i</em>.  <a href="#a717a2e1fdf5402ffa6f811d5f5477248">More...</a><br/></td></tr>
<tr class="separator:a717a2e1fdf5402ffa6f811d5f5477248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655cf22d71a72a4d6fc61794beff1f31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a655cf22d71a72a4d6fc61794beff1f31">set_anno_s16</a> (int i, int16_t x)</td></tr>
<tr class="memdesc:a655cf22d71a72a4d6fc61794beff1f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set 16-bit annotation at offset <em>i</em>.  <a href="#a655cf22d71a72a4d6fc61794beff1f31">More...</a><br/></td></tr>
<tr class="separator:a655cf22d71a72a4d6fc61794beff1f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0016128185e8c5c36fb6a0024e78be92"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a0016128185e8c5c36fb6a0024e78be92">anno_u32</a> (int i) const </td></tr>
<tr class="memdesc:a0016128185e8c5c36fb6a0024e78be92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 32-bit annotation at offset <em>i</em>.  <a href="#a0016128185e8c5c36fb6a0024e78be92">More...</a><br/></td></tr>
<tr class="separator:a0016128185e8c5c36fb6a0024e78be92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214f3cee1b33a8d003fcbca241a0c205"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a214f3cee1b33a8d003fcbca241a0c205">set_anno_u32</a> (int i, uint32_t x)</td></tr>
<tr class="memdesc:a214f3cee1b33a8d003fcbca241a0c205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set 32-bit annotation at offset <em>i</em>.  <a href="#a214f3cee1b33a8d003fcbca241a0c205">More...</a><br/></td></tr>
<tr class="separator:a214f3cee1b33a8d003fcbca241a0c205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02f2c5cd3e413761d75a864947d1baa"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#ab02f2c5cd3e413761d75a864947d1baa">anno_s32</a> (int i) const </td></tr>
<tr class="memdesc:ab02f2c5cd3e413761d75a864947d1baa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 32-bit annotation at offset <em>i</em>.  <a href="#ab02f2c5cd3e413761d75a864947d1baa">More...</a><br/></td></tr>
<tr class="separator:ab02f2c5cd3e413761d75a864947d1baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576e2ff60d6743bd603f8cf0bf1030dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a576e2ff60d6743bd603f8cf0bf1030dd">set_anno_s32</a> (int i, int32_t x)</td></tr>
<tr class="memdesc:a576e2ff60d6743bd603f8cf0bf1030dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set 32-bit annotation at offset <em>i</em>.  <a href="#a576e2ff60d6743bd603f8cf0bf1030dd">More...</a><br/></td></tr>
<tr class="separator:a576e2ff60d6743bd603f8cf0bf1030dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a75ab357039920c16cf02b136fec5c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#ad9a75ab357039920c16cf02b136fec5c">anno_u64</a> (int i) const </td></tr>
<tr class="memdesc:ad9a75ab357039920c16cf02b136fec5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 64-bit annotation at offset <em>i</em>.  <a href="#ad9a75ab357039920c16cf02b136fec5c">More...</a><br/></td></tr>
<tr class="separator:ad9a75ab357039920c16cf02b136fec5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fba10b6dbe02158ab17ee34355fd395"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a1fba10b6dbe02158ab17ee34355fd395">set_anno_u64</a> (int i, uint64_t x)</td></tr>
<tr class="memdesc:a1fba10b6dbe02158ab17ee34355fd395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set 64-bit annotation at offset <em>i</em>.  <a href="#a1fba10b6dbe02158ab17ee34355fd395">More...</a><br/></td></tr>
<tr class="separator:a1fba10b6dbe02158ab17ee34355fd395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7677b7202502c016bf8bdc4b6ec9ee"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a0d7677b7202502c016bf8bdc4b6ec9ee">anno_ptr</a> (int i) const </td></tr>
<tr class="memdesc:a0d7677b7202502c016bf8bdc4b6ec9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return void * sized annotation at offset <em>i</em>.  <a href="#a0d7677b7202502c016bf8bdc4b6ec9ee">More...</a><br/></td></tr>
<tr class="separator:a0d7677b7202502c016bf8bdc4b6ec9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722a3eea016326a6c1ef583afb662579"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a722a3eea016326a6c1ef583afb662579">set_anno_ptr</a> (int i, const void *x)</td></tr>
<tr class="memdesc:a722a3eea016326a6c1ef583afb662579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set void * sized annotation at offset <em>i</em>.  <a href="#a722a3eea016326a6c1ef583afb662579">More...</a><br/></td></tr>
<tr class="separator:a722a3eea016326a6c1ef583afb662579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e4ba859ee7ef8d4bd2561da9eb150c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#ae6e4ba859ee7ef8d4bd2561da9eb150c">clear_annotations</a> (bool all=true)</td></tr>
<tr class="memdesc:ae6e4ba859ee7ef8d4bd2561da9eb150c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all packet annotations.  <a href="#ae6e4ba859ee7ef8d4bd2561da9eb150c">More...</a><br/></td></tr>
<tr class="separator:ae6e4ba859ee7ef8d4bd2561da9eb150c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9f660eec3b4f166763d3c54db6e3c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_packet.html#a7f9f660eec3b4f166763d3c54db6e3c4">copy_annotations</a> (const <a class="el" href="class_packet.html">Packet</a> *)</td></tr>
<tr class="memdesc:a7f9f660eec3b4f166763d3c54db6e3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy most packet annotations from <em>p</em>.  <a href="#a7f9f660eec3b4f166763d3c54db6e3c4">More...</a><br/></td></tr>
<tr class="separator:a7f9f660eec3b4f166763d3c54db6e3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A network packet. </p>
<p>Click's <a class="el" href="class_packet.html" title="A network packet. ">Packet</a> class represents network packets within a router. <a class="el" href="class_packet.html" title="A network packet. ">Packet</a> objects are passed from <a class="el" href="class_element.html" title="Base class for Click elements. ">Element</a> to <a class="el" href="class_element.html" title="Base class for Click elements. ">Element</a> via the <a class="el" href="class_element.html#af63395e97dd323b90d427e2eaae087eb" title="Push packet p onto push input port. ">Element::push()</a> and <a class="el" href="class_element.html#ace8c7b8b37f177b9a9cc024d8b64f3a3" title="Pull a packet from pull output port. ">Element::pull()</a> functions. The vast majority of elements handle packets.</p>
<p>A packet consists of a <em>data buffer</em>, which stores the actual packet wire data, and a set of <em>annotations</em>, which store extra information calculated about the packet, such as the destination address to be used for routing. Every <a class="el" href="class_packet.html" title="A network packet. ">Packet</a> object has different annotations, but a data buffer may be shared among multiple <a class="el" href="class_packet.html" title="A network packet. ">Packet</a> objects, saving memory and speeding up packet copies. (See <a class="el" href="class_packet.html#aa274049bd162e38785c514fa512c44e8" title="Create a clone of this packet. ">Packet::clone</a>.) As a result a <a class="el" href="class_packet.html" title="A network packet. ">Packet</a>'s data buffer is not writable. To write into a packet, turn it into a nonshared <a class="el" href="class_writable_packet.html" title="A network packet believed not to be shared. ">WritablePacket</a> first, using <a class="el" href="class_packet.html#a6fcf41ec1dd9ad25d59776d1bab983a3" title="Return an unshared packet containing this packet&#39;s data. ">uniqueify()</a>, <a class="el" href="class_packet.html#a65f07d2050c0eac6625e271c6d3398ea" title="Add space for a header before the packet. ">push()</a>, or <a class="el" href="class_packet.html#a2d977927daa81b1b26607ebd4d3dde6c" title="Add space for data after the packet. ">put()</a>.</p>
<h3>Data Buffer</h3>
<p>A packet's data buffer is a single flat array of bytes. The buffer may be larger than the actual packet data, leaving unused spaces called <em>headroom</em> and <em>tailroom</em> before and after the data proper. Prepending headers or appending data to a packet can be quite efficient if there is enough headroom or tailroom.</p>
<p>The relationships among a <a class="el" href="class_packet.html" title="A network packet. ">Packet</a> object's data buffer variables is shown here:</p>
<pre>
                    <a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">data()</a>               <a class="el" href="class_packet.html#a0e09d33c102240db56b2a43f30c1886d" title="Return the packet&#39;s end data pointer. ">end_data()</a>
                       |                      |
      |&lt;- <a class="el" href="class_packet.html#a1c32d409a895a910bf053e31553dc5a7" title="Return the packet&#39;s headroom. ">headroom()</a> -&gt;|&lt;----- <a class="el" href="class_packet.html#a70d251ee2af3e1acacbd5026e264ca34" title="Return the packet&#39;s length. ">length()</a> -----&gt;|&lt;- <a class="el" href="class_packet.html#ae5a9987122def9cf9e3973173cb8df87" title="Return the packet&#39;s tailroom. ">tailroom()</a> -&gt;|
      |                v                      v                |
      +================+======================+================+
      |XXXXXXXXXXXXXXXX|   PACKET CONTENTS    |XXXXXXXXXXXXXXXX|
      +================+======================+================+
      ^                                                        ^
      |&lt;------------------ <a class="el" href="class_packet.html#afb06d9a3645eb12d16e04008aead92f6" title="Return the packet&#39;s buffer length. ">buffer_length()</a> -------------------&gt;|
      |                                                        |
   <a class="el" href="class_packet.html#adbe89b8828541d410cb31ee2145e7a8c" title="Return a pointer to the packet&#39;s data buffer. ">buffer()</a>                                               <a class="el" href="class_packet.html#a7b4556d1300bb7a95e23b6657294714d" title="Return the packet&#39;s end data buffer pointer. ">end_buffer()</a>
</pre><p>Most code that manipulates packets is interested only in <a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">data()</a> and <a class="el" href="class_packet.html#a70d251ee2af3e1acacbd5026e264ca34" title="Return the packet&#39;s length. ">length()</a>.</p>
<p>To create a <a class="el" href="class_packet.html" title="A network packet. ">Packet</a>, call one of the <a class="el" href="class_packet.html#a3f7e476f1fbd63881c077cf4941b0277" title="Create and return a new packet. ">make()</a> functions. To destroy a <a class="el" href="class_packet.html" title="A network packet. ">Packet</a>, call <a class="el" href="class_packet.html#a4c95c6ebd45e8c7d1b85b22b27b29118" title="Delete this packet. ">kill()</a>. To clone a <a class="el" href="class_packet.html" title="A network packet. ">Packet</a>, which creates a new <a class="el" href="class_packet.html" title="A network packet. ">Packet</a> object that shares this packet's data, call <a class="el" href="class_packet.html#aa274049bd162e38785c514fa512c44e8" title="Create a clone of this packet. ">clone()</a>. To uniqueify a <a class="el" href="class_packet.html" title="A network packet. ">Packet</a>, which unshares the packet data if necessary, call <a class="el" href="class_packet.html#a6fcf41ec1dd9ad25d59776d1bab983a3" title="Return an unshared packet containing this packet&#39;s data. ">uniqueify()</a>. To allocate extra space for headers or trailers, call <a class="el" href="class_packet.html#a65f07d2050c0eac6625e271c6d3398ea" title="Add space for a header before the packet. ">push()</a> and <a class="el" href="class_packet.html#a2d977927daa81b1b26607ebd4d3dde6c" title="Add space for data after the packet. ">put()</a>. To remove headers or trailers, call <a class="el" href="class_packet.html#a54f817fb5d15980cc1d5bb27e851e85f" title="Remove a header from the front of the packet. ">pull()</a> and <a class="el" href="class_packet.html#abdff7a45566ae198c9ed246707d5317f" title="Remove space from the end of the packet. ">take()</a>.</p>
<pre>
               <a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">data()</a>                          <a class="el" href="class_packet.html#a0e09d33c102240db56b2a43f30c1886d" title="Return the packet&#39;s end data pointer. ">end_data()</a>
                  |                                |
          <a class="el" href="class_packet.html#a65f07d2050c0eac6625e271c6d3398ea" title="Add space for a header before the packet. ">push()</a>  |  <a class="el" href="class_packet.html#a54f817fb5d15980cc1d5bb27e851e85f" title="Remove a header from the front of the packet. ">pull()</a>                <a class="el" href="class_packet.html#abdff7a45566ae198c9ed246707d5317f" title="Remove space from the end of the packet. ">take()</a>  |  <a class="el" href="class_packet.html#a2d977927daa81b1b26607ebd4d3dde6c" title="Add space for data after the packet. ">put()</a>
         &lt;======= | =======&gt;              &lt;======= | =======&gt;
                  v                                v
      +===========+================================+===========+
      |XXXXXXXXXXX|        PACKET CONTENTS         |XXXXXXXXXXX|
      +===========+================================+===========+
</pre><p><a class="el" href="class_packet.html" title="A network packet. ">Packet</a> objects are implemented in different ways in different drivers. The userlevel driver has its own C++ implementation. In the linuxmodule driver, however, <a class="el" href="class_packet.html" title="A network packet. ">Packet</a> is an overlay on Linux's native sk_buff object: the <a class="el" href="class_packet.html" title="A network packet. ">Packet</a> methods access underlying sk_buff data directly, with no overhead. (For example, <a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">Packet::data()</a> returns the sk_buff's data field.)</p>
<h3>Annotations</h3>
<p>Annotations are extra information about a packet above and beyond the packet data. <a class="el" href="class_packet.html" title="A network packet. ">Packet</a> supports several specific annotations, plus a <em>user annotation area</em> available for arbitrary use by elements.</p>
<ul>
<li>
<b>Header pointers:</b> Each packet has three header pointers, designed to point to the packet's MAC header, network header, and transport header, respectively. Convenience functions like <a class="el" href="class_packet.html#a021870cf51b52aa40f3861affa9a1357" title="Return the packet&#39;s network header pointer as IPv4. ">ip_header()</a> access these pointers cast to common header types. The header pointers are kept up to date when operations like <a class="el" href="class_packet.html#a65f07d2050c0eac6625e271c6d3398ea" title="Add space for a header before the packet. ">push()</a> or <a class="el" href="class_packet.html#a6fcf41ec1dd9ad25d59776d1bab983a3" title="Return an unshared packet containing this packet&#39;s data. ">uniqueify()</a> change the packet's data buffer. Header pointers can be null, and they can even point to memory outside the current packet data bounds. For example, a MAC header pointer will remain set even after <a class="el" href="class_packet.html#a54f817fb5d15980cc1d5bb27e851e85f" title="Remove a header from the front of the packet. ">pull()</a> is used to shift the packet data past the MAC header. As a result, functions like <a class="el" href="class_packet.html#a16d9ef137618c8d8ff0b3e451622df4e" title="Return the offset from the packet data to the MAC header. ">mac_header_offset()</a> can return negative numbers. </li>
<li>
<b><a class="el" href="class_timestamp.html" title="Represents a moment or interval in time. ">Timestamp</a>:</b> A timestamp associated with the packet. Most packet sources timestamp packets when they enter the router; other elements examine or modify the timestamp. </li>
<li>
<b>Device:</b> A pointer to the device on which the packet arrived. Only meaningful in the linuxmodule driver, but provided in every driver. </li>
<li>
<b><a class="el" href="class_packet.html" title="A network packet. ">Packet</a> type:</b> A small integer indicating whether the packet is meant for this host, broadcast, multicast, or some other purpose. Several elements manipulate this annotation; in linuxmodule, setting the annotation is required for the host network stack to process incoming packets correctly. </li>
<li>
<b>Performance counter</b> (linuxmodule only): A 64-bit integer intended to hold a performance counter value. Used by SetCycleCount and others. </li>
<li>
<b>Next and previous packet:</b> Pointers provided to allow elements to chain packets into a doubly linked list. </li>
<li>
<b>Annotations:</b> Each packet has <a class="el" href="class_packet.html#a9da06ca41f8744c66f57db271302fbbba37ffbe2ed8e612868890511c356dc4f7">anno_size </a> bytes available for annotations. Elements agree to use portions of the annotation area to communicate per-packet information. Macros in the &lt;<a class="el" href="packet__anno_8hh_source.html">click/packet_anno.hh</a>&gt; header file define the annotations used by Click's current elements. One common annotation is the network address annotation &ndash; see <a class="el" href="class_packet.html#ab6d4c6488d28abea4e14ea84b90be64a" title="Return the destination IPv4 address annotation. ">Packet::dst_ip_anno()</a>. Routing elements, such as RadixIPLookup, set the address annotation to indicate the desired next hop; ARPQuerier uses this annotation to query the next hop's MAC. </li>
</ul>
<p>New packets start wth all annotations set to zero or null. Cloning a packet copies its annotations. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a7f1a7f4452ceaddcae7fe82b072b5b71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a7f1a7f4452ceaddcae7fe82b072b5b71a1e08f43e330fdd6cc410e3a4e8a81ea8"></a>default_headroom</em>&#160;</td><td class="fielddoc">
<p>Default packet <a class="el" href="class_packet.html#a1c32d409a895a910bf053e31553dc5a7" title="Return the packet&#39;s headroom. ">headroom()</a> for <a class="el" href="class_packet.html#a3f7e476f1fbd63881c077cf4941b0277" title="Create and return a new packet. ">Packet::make()</a>. 4-byte aligned. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a7f1a7f4452ceaddcae7fe82b072b5b71ae12286b32f83242acb34ee02dab24802"></a>min_buffer_length</em>&#160;</td><td class="fielddoc">
<p>Minimum <a class="el" href="class_packet.html#afb06d9a3645eb12d16e04008aead92f6" title="Return the packet&#39;s buffer length. ">buffer_length()</a> for <a class="el" href="class_packet.html#a3f7e476f1fbd63881c077cf4941b0277" title="Create and return a new packet. ">Packet::make()</a> </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a9da06ca41f8744c66f57db271302fbbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a9da06ca41f8744c66f57db271302fbbba37ffbe2ed8e612868890511c356dc4f7"></a>anno_size</em>&#160;</td><td class="fielddoc">
<p>Size of annotation area. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a99d687a19a8f94b7625c57a809c9f65b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_packet.html#a99d687a19a8f94b7625c57a809c9f65b">Packet::PacketType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Values for <a class="el" href="class_packet.html#ac56ee973f22d65c9a2c7b20df7de3035" title="Return the packet type annotation. ">packet_type_anno()</a>. Must agree with Linux's PACKET_ constants in &lt;linux/if_packet.h&gt;. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a99d687a19a8f94b7625c57a809c9f65ba917357cae65d61b57f8e36b3bead7451"></a>HOST</em>&#160;</td><td class="fielddoc">
<p><a class="el" href="class_packet.html" title="A network packet. ">Packet</a> was sent to this host. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a99d687a19a8f94b7625c57a809c9f65ba9c7a27245a5f68b25553cca5b2f9e507"></a>BROADCAST</em>&#160;</td><td class="fielddoc">
<p><a class="el" href="class_packet.html" title="A network packet. ">Packet</a> was sent to a link-level multicast address. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a99d687a19a8f94b7625c57a809c9f65ba7628b46f4730f2cf71b0c94bd8fbcd44"></a>MULTICAST</em>&#160;</td><td class="fielddoc">
<p><a class="el" href="class_packet.html" title="A network packet. ">Packet</a> was sent to a link-level multicast address. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a99d687a19a8f94b7625c57a809c9f65ba3daed014fd8bc428f9d9c057cef5f2cb"></a>OTHERHOST</em>&#160;</td><td class="fielddoc">
<p><a class="el" href="class_packet.html" title="A network packet. ">Packet</a> was sent to a different host, but received anyway. The receiving device is probably in promiscuous mode. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a99d687a19a8f94b7625c57a809c9f65ba4a4c2329032aadc304b3ada1e65f9a6e"></a>OUTGOING</em>&#160;</td><td class="fielddoc">
<p><a class="el" href="class_packet.html" title="A network packet. ">Packet</a> was generated by this host and is being sent elsewhere. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a3f7e476f1fbd63881c077cf4941b0277"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_writable_packet.html">WritablePacket</a> * Packet::make </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>headroom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>tailroom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create and return a new packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">headroom</td><td>headroom in new packet </td></tr>
    <tr><td class="paramname">data</td><td>data to be copied into the new packet </td></tr>
    <tr><td class="paramname">length</td><td>length of packet </td></tr>
    <tr><td class="paramname">tailroom</td><td>tailroom in new packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new packet, or null if no packet could be created</dd></dl>
<p>The <em>data</em> is copied into the new packet. If <em>data</em> is null, the packet's data is left uninitialized. The resulting packet's <a class="el" href="class_packet.html#afb06d9a3645eb12d16e04008aead92f6" title="Return the packet&#39;s buffer length. ">buffer_length()</a> will be at least <a class="el" href="class_packet.html#a7f1a7f4452ceaddcae7fe82b072b5b71ae12286b32f83242acb34ee02dab24802">min_buffer_length </a>; if <em>headroom</em> + <em>length</em> + <em>tailroom</em> would be less, then <em>tailroom</em> is increased to make the total <a class="el" href="class_packet.html#a7f1a7f4452ceaddcae7fe82b072b5b71ae12286b32f83242acb34ee02dab24802">min_buffer_length </a>.</p>
<p>The new packet's annotations are cleared and its header pointers are null. </p>

</div>
</div>
<a class="anchor" id="a5488fd79cc716d6b65cc70a91fd6c47b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_writable_packet.html">WritablePacket</a> * Packet::make </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create and return a new packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>data to be copied into the new packet </td></tr>
    <tr><td class="paramname">length</td><td>length of packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new packet, or null if no packet could be created</dd></dl>
<p>The <em>data</em> is copied into the new packet. If <em>data</em> is null, the packet's data is left uninitialized. The new packet's headroom equals <a class="el" href="class_packet.html#a7f1a7f4452ceaddcae7fe82b072b5b71a1e08f43e330fdd6cc410e3a4e8a81ea8">default_headroom </a>, its tailroom is 0.</p>
<p>The returned packet's annotations are cleared and its header pointers are null. </p>

</div>
</div>
<a class="anchor" id="a76ce2535324d0ffb0cd7d2511f4126ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_writable_packet.html">WritablePacket</a> * Packet::make </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create and return a new packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>length of packet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new packet, or null if no packet could be created</dd></dl>
<p>The packet's data is left uninitialized. The new packet's headroom equals <a class="el" href="class_packet.html#a7f1a7f4452ceaddcae7fe82b072b5b71a1e08f43e330fdd6cc410e3a4e8a81ea8">default_headroom </a>, its tailroom is 0.</p>
<p>The returned packet's annotations are cleared and its header pointers are null. </p>

</div>
</div>
<a class="anchor" id="a11a67b80511e3161349f6bdd040faf86"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_packet.html">Packet</a> * Packet::make </td>
          <td>(</td>
          <td class="paramtype">struct sk_buff *&#160;</td>
          <td class="paramname"><em>skb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change an sk_buff into a <a class="el" href="class_packet.html" title="A network packet. ">Packet</a> (linuxmodule). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skb</td><td>input sk_buff </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the packet</dd></dl>
<p>In the Linux kernel module, <a class="el" href="class_packet.html" title="A network packet. ">Packet</a> objects are sk_buff objects. This function simply changes an sk_buff into a <a class="el" href="class_packet.html" title="A network packet. ">Packet</a> by claiming its <em>skb</em> argument. If <code>skb-&gt;users</code> is 1, then <em>skb</em> is orphaned by <code>skb_orphan(skb)</code> and returned. If it is larger than 1, then <em>skb</em> is cloned and the clone is returned. (sk_buffs used for Click <a class="el" href="class_packet.html" title="A network packet. ">Packet</a> objects must have <code>skb-&gt;users</code> == 1.) Null might be returned if there's no memory for the clone.</p>
<p>The returned packet's annotations and header pointers <em>are not cleared</em>: they have the same values they did in the sk_buff. If the packet came from Linux, then the header pointers and shared annotations (timestamp, packet type, next/prev packet) might have valid values, but the Click annotations (address, user) likely do not. Use <a class="el" href="class_packet.html#ae6e4ba859ee7ef8d4bd2561da9eb150c" title="Clear all packet annotations. ">clear_annotations()</a> to clear them. </p>

</div>
</div>
<a class="anchor" id="a40e3a7be2d7dc76e83fa5baff36c5fce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_writable_packet.html">WritablePacket</a> * Packet::make </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">buffer_destructor_type&#160;</td>
          <td class="paramname"><em>destructor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>argument</em> = <code>(void*)&#160;0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>headroom</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tailroom</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create and return a new packet (userlevel). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>data used in the new packet </td></tr>
    <tr><td class="paramname">length</td><td>length of packet </td></tr>
    <tr><td class="paramname">destructor</td><td>destructor function </td></tr>
    <tr><td class="paramname">argument</td><td>argument to destructor function </td></tr>
    <tr><td class="paramname">headroom</td><td>headroom available before the data pointer </td></tr>
    <tr><td class="paramname">tailroom</td><td>tailroom available after data + length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new packet, or null if no packet could be created</dd></dl>
<p>The packet's data pointer becomes the <em>data:</em> the data is not copied into the new packet, rather the packet owns the <em>data</em> pointer. When the packet's data is eventually destroyed, either because the packet is deleted or because of something like a <a class="el" href="class_packet.html#a65f07d2050c0eac6625e271c6d3398ea" title="Add space for a header before the packet. ">push()</a> or full(), the <em>destructor</em> will be called as <em>destructor</em>(<em>data</em>, <em>length</em>, <em>argument</em>). (If <em>destructor</em> is null, the packet data will be freed by <code>delete[] <em>data</code></em>.) The packet has zero headroom and tailroom.</p>
<p>The returned packet's annotations are cleared and its header pointers are null. </p>

</div>
</div>
<a class="anchor" id="a4c95c6ebd45e8c7d1b85b22b27b29118"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::kill </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete this packet. </p>
<p>The packet header (including annotations) is destroyed and its memory returned to the system. The packet's data is also freed if this is the last clone. </p>

</div>
</div>
<a class="anchor" id="aba191909862d94edefb19d4b5f548cf7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::shared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test whether this packet's data is shared. </p>
<p>Returns true iff the packet's data is shared. If <a class="el" href="class_packet.html#aba191909862d94edefb19d4b5f548cf7" title="Test whether this packet&#39;s data is shared. ">shared()</a> is false, then the result of <a class="el" href="class_packet.html#a6fcf41ec1dd9ad25d59776d1bab983a3" title="Return an unshared packet containing this packet&#39;s data. ">uniqueify()</a> will equal <code>this</code>. </p>

</div>
</div>
<a class="anchor" id="aa274049bd162e38785c514fa512c44e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_packet.html">Packet</a> * Packet::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a clone of this packet. </p>
<dl class="section return"><dt>Returns</dt><dd>the cloned packet</dd></dl>
<p>The returned clone has independent annotations, initially copied from this packet, but shares this packet's data. <a class="el" href="class_packet.html#aba191909862d94edefb19d4b5f548cf7" title="Test whether this packet&#39;s data is shared. ">shared()</a> returns true for both the packet and its clone. Returns null if there's no memory for the clone. </p>

</div>
</div>
<a class="anchor" id="a6fcf41ec1dd9ad25d59776d1bab983a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_writable_packet.html">WritablePacket</a> * Packet::uniqueify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an unshared packet containing this packet's data. </p>
<dl class="section return"><dt>Returns</dt><dd>the unshared packet, which is writable</dd></dl>
<p>The returned packet's data is unshared with any other packet, so it's safe to write the data. If <a class="el" href="class_packet.html#aba191909862d94edefb19d4b5f548cf7" title="Test whether this packet&#39;s data is shared. ">shared()</a> is false, this operation simply returns the input packet. If <a class="el" href="class_packet.html#aba191909862d94edefb19d4b5f548cf7" title="Test whether this packet&#39;s data is shared. ">shared()</a> is true, <a class="el" href="class_packet.html#a6fcf41ec1dd9ad25d59776d1bab983a3" title="Return an unshared packet containing this packet&#39;s data. ">uniqueify()</a> makes a copy of the data. The input packet is freed if the copy fails.</p>
<p>The returned <a class="el" href="class_writable_packet.html" title="A network packet believed not to be shared. ">WritablePacket</a> pointer may not equal the input <a class="el" href="class_packet.html" title="A network packet. ">Packet</a> pointer, so do not use the input pointer after the <a class="el" href="class_packet.html#a6fcf41ec1dd9ad25d59776d1bab983a3" title="Return an unshared packet containing this packet&#39;s data. ">uniqueify()</a> call.</p>
<p>The input packet's headroom and tailroom areas are copied in addition to its true contents. The header annotations are shifted to point into the new packet data if necessary.</p>
<p><a class="el" href="class_packet.html#a6fcf41ec1dd9ad25d59776d1bab983a3" title="Return an unshared packet containing this packet&#39;s data. ">uniqueify()</a> is usually used like this: </p>
<div class="fragment"><div class="line"><a class="code" href="class_writable_packet.html">WritablePacket</a> *q = p-&gt;<a class="code" href="class_packet.html#a6fcf41ec1dd9ad25d59776d1bab983a3">uniqueify</a>();</div>
<div class="line"><span class="keywordflow">if</span> (!q)</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="comment">// p must not be used here.</span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a547fb52b84a4e9a74bd1f4599665098b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char * Packet::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the packet's data pointer. </p>
<p>This is the pointer to the first byte of packet data. </p>

</div>
</div>
<a class="anchor" id="a0e09d33c102240db56b2a43f30c1886d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char * Packet::end_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the packet's end data pointer. </p>
<p>The result points at the byte following the packet data. </p>
<dl class="section invariant"><dt>Invariant</dt><dd><a class="el" href="class_packet.html#a0e09d33c102240db56b2a43f30c1886d" title="Return the packet&#39;s end data pointer. ">end_data()</a> == <a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">data()</a> + <a class="el" href="class_packet.html#a70d251ee2af3e1acacbd5026e264ca34" title="Return the packet&#39;s length. ">length()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a70d251ee2af3e1acacbd5026e264ca34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Packet::length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the packet's length. </p>

</div>
</div>
<a class="anchor" id="a1c32d409a895a910bf053e31553dc5a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Packet::headroom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the packet's headroom. </p>
<p>The headroom is the amount of space available in the current packet buffer before <a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">data()</a>. A <a class="el" href="class_packet.html#a65f07d2050c0eac6625e271c6d3398ea" title="Add space for a header before the packet. ">push()</a> operation is cheap if the packet's unshared and the length pushed is less than <a class="el" href="class_packet.html#a1c32d409a895a910bf053e31553dc5a7" title="Return the packet&#39;s headroom. ">headroom()</a>. </p>

</div>
</div>
<a class="anchor" id="ae5a9987122def9cf9e3973173cb8df87"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Packet::tailroom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the packet's tailroom. </p>
<p>The tailroom is the amount of space available in the current packet buffer following <a class="el" href="class_packet.html#a0e09d33c102240db56b2a43f30c1886d" title="Return the packet&#39;s end data pointer. ">end_data()</a>. A <a class="el" href="class_packet.html#a2d977927daa81b1b26607ebd4d3dde6c" title="Add space for data after the packet. ">put()</a> operation is cheap if the packet's unshared and the length put is less than <a class="el" href="class_packet.html#ae5a9987122def9cf9e3973173cb8df87" title="Return the packet&#39;s tailroom. ">tailroom()</a>. </p>

</div>
</div>
<a class="anchor" id="adbe89b8828541d410cb31ee2145e7a8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char * Packet::buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the packet's data buffer. </p>
<p>The result points at the packet's headroom, not its data. </p>
<dl class="section invariant"><dt>Invariant</dt><dd><a class="el" href="class_packet.html#adbe89b8828541d410cb31ee2145e7a8c" title="Return a pointer to the packet&#39;s data buffer. ">buffer()</a> == <a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">data()</a> - <a class="el" href="class_packet.html#a1c32d409a895a910bf053e31553dc5a7" title="Return the packet&#39;s headroom. ">headroom()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7b4556d1300bb7a95e23b6657294714d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char * Packet::end_buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the packet's end data buffer pointer. </p>
<p>The result points past the packet's tailroom. </p>
<dl class="section invariant"><dt>Invariant</dt><dd><a class="el" href="class_packet.html#a7b4556d1300bb7a95e23b6657294714d" title="Return the packet&#39;s end data buffer pointer. ">end_buffer()</a> == <a class="el" href="class_packet.html#a0e09d33c102240db56b2a43f30c1886d" title="Return the packet&#39;s end data pointer. ">end_data()</a> + <a class="el" href="class_packet.html#ae5a9987122def9cf9e3973173cb8df87" title="Return the packet&#39;s tailroom. ">tailroom()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afb06d9a3645eb12d16e04008aead92f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Packet::buffer_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the packet's buffer length. </p>
<dl class="section invariant"><dt>Invariant</dt><dd><a class="el" href="class_packet.html#afb06d9a3645eb12d16e04008aead92f6" title="Return the packet&#39;s buffer length. ">buffer_length()</a> == <a class="el" href="class_packet.html#a1c32d409a895a910bf053e31553dc5a7" title="Return the packet&#39;s headroom. ">headroom()</a> + <a class="el" href="class_packet.html#a70d251ee2af3e1acacbd5026e264ca34" title="Return the packet&#39;s length. ">length()</a> + <a class="el" href="class_packet.html#ae5a9987122def9cf9e3973173cb8df87" title="Return the packet&#39;s tailroom. ">tailroom()</a> </dd>
<dd>
<a class="el" href="class_packet.html#adbe89b8828541d410cb31ee2145e7a8c" title="Return a pointer to the packet&#39;s data buffer. ">buffer()</a> + <a class="el" href="class_packet.html#afb06d9a3645eb12d16e04008aead92f6" title="Return the packet&#39;s buffer length. ">buffer_length()</a> == <a class="el" href="class_packet.html#a7b4556d1300bb7a95e23b6657294714d" title="Return the packet&#39;s end data buffer pointer. ">end_buffer()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a65f07d2050c0eac6625e271c6d3398ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_writable_packet.html">WritablePacket</a> * Packet::push </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add space for a header before the packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>amount of space to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet with added header space, or null on failure</dd></dl>
<p>Returns a packet with an additional <em>len</em> bytes of uninitialized space before the current packet's <a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">data()</a>. A copy of the packet data is made if there isn't enough <a class="el" href="class_packet.html#a1c32d409a895a910bf053e31553dc5a7" title="Return the packet&#39;s headroom. ">headroom()</a> in the current packet, or if the current packet is <a class="el" href="class_packet.html#aba191909862d94edefb19d4b5f548cf7" title="Test whether this packet&#39;s data is shared. ">shared()</a>. If no copy is made, this operation is quite efficient.</p>
<p>If a data copy would be required, but the copy fails because of lack of memory, then the current packet is freed.</p>
<p><a class="el" href="class_packet.html#a65f07d2050c0eac6625e271c6d3398ea" title="Add space for a header before the packet. ">push()</a> is usually used like this: </p>
<div class="fragment"><div class="line"><a class="code" href="class_writable_packet.html">WritablePacket</a> *q = p-&gt;<a class="code" href="class_packet.html#a65f07d2050c0eac6625e271c6d3398ea">push</a>(14);</div>
<div class="line"><span class="keywordflow">if</span> (!q)</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="comment">// p must not be used here.</span></div>
</div><!-- fragment --><dl class="section post"><dt>Postcondition</dt><dd>new <a class="el" href="class_packet.html#a70d251ee2af3e1acacbd5026e264ca34" title="Return the packet&#39;s length. ">length()</a> == old <a class="el" href="class_packet.html#a70d251ee2af3e1acacbd5026e264ca34" title="Return the packet&#39;s length. ">length()</a> + <em>len</em> (if no failure)</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#a5953d4a49ce5f919eb6e9f46b7de25ff" title="Add space for a header before the packet. ">nonunique_push</a>, <a class="el" href="class_packet.html#a48d9b58effdf1a3a52baa3791782c466" title="Add space for a MAC header before the packet. ">push_mac_header</a>, <a class="el" href="class_packet.html#a54f817fb5d15980cc1d5bb27e851e85f" title="Remove a header from the front of the packet. ">pull</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a48d9b58effdf1a3a52baa3791782c466"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_writable_packet.html">WritablePacket</a> * Packet::push_mac_header </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add space for a MAC header before the packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>amount of space to add and length of MAC header </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet with added header space, or null on failure</dd></dl>
<p>Combines the action of <a class="el" href="class_packet.html#a65f07d2050c0eac6625e271c6d3398ea" title="Add space for a header before the packet. ">push()</a> and <a class="el" href="class_packet.html#a228aa94d61f826f5020917375d39d05d" title="Set the MAC header pointer. ">set_mac_header()</a>. <em>len</em> bytes are pushed for a MAC header, and on success, the packet's returned MAC and network header pointers are set as by set_mac_header(<a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">data()</a>, <em>len</em>).</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#a65f07d2050c0eac6625e271c6d3398ea" title="Add space for a header before the packet. ">push</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5953d4a49ce5f919eb6e9f46b7de25ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_packet.html">Packet</a> * Packet::nonunique_push </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add space for a header before the packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>amount of space to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet with added header space, or null on failure</dd></dl>
<p>This is a variant of <a class="el" href="class_packet.html#a65f07d2050c0eac6625e271c6d3398ea" title="Add space for a header before the packet. ">push()</a>. Returns a packet with an additional <em>len</em> bytes of uninitialized space before the current packet's <a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">data()</a>. A copy of the packet data is made if there isn't enough <a class="el" href="class_packet.html#a1c32d409a895a910bf053e31553dc5a7" title="Return the packet&#39;s headroom. ">headroom()</a> in the current packet. However, no copy is made if the current packet is shared; and if no copy is made, this operation is quite efficient.</p>
<p>If a data copy would be required, but the copy fails because of lack of memory, then the current packet is freed.</p>
<dl class="section note"><dt>Note</dt><dd>Unlike <a class="el" href="class_packet.html#a65f07d2050c0eac6625e271c6d3398ea" title="Add space for a header before the packet. ">push()</a>, <a class="el" href="class_packet.html#a5953d4a49ce5f919eb6e9f46b7de25ff" title="Add space for a header before the packet. ">nonunique_push()</a> returns a <a class="el" href="class_packet.html" title="A network packet. ">Packet</a> object, which has non-writable data.</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#a65f07d2050c0eac6625e271c6d3398ea" title="Add space for a header before the packet. ">push</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a54f817fb5d15980cc1d5bb27e851e85f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::pull </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove a header from the front of the packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>amount of space to remove</td></tr>
  </table>
  </dd>
</dl>
<p>Removes <em>len</em> bytes from the initial part of the packet, usually corresponding to some network header (for example, pull(14) removes an Ethernet header). This operation is efficient: it just bumps a pointer.</p>
<p>It is an error to attempt to pull more than <a class="el" href="class_packet.html#a70d251ee2af3e1acacbd5026e264ca34" title="Return the packet&#39;s length. ">length()</a> bytes.</p>
<dl class="section post"><dt>Postcondition</dt><dd>new <a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">data()</a> == old <a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">data()</a> + <em>len</em> </dd>
<dd>
new <a class="el" href="class_packet.html#a70d251ee2af3e1acacbd5026e264ca34" title="Return the packet&#39;s length. ">length()</a> == old <a class="el" href="class_packet.html#a70d251ee2af3e1acacbd5026e264ca34" title="Return the packet&#39;s length. ">length()</a> - <em>len</em> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#a65f07d2050c0eac6625e271c6d3398ea" title="Add space for a header before the packet. ">push</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2d977927daa81b1b26607ebd4d3dde6c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_writable_packet.html">WritablePacket</a> * Packet::put </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add space for data after the packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>amount of space to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet with added trailer space, or null on failure</dd></dl>
<p>Returns a packet with an additional <em>len</em> bytes of uninitialized space after the current packet's data (starting at <a class="el" href="class_packet.html#a0e09d33c102240db56b2a43f30c1886d" title="Return the packet&#39;s end data pointer. ">end_data()</a>). A copy of the packet data is made if there isn't enough <a class="el" href="class_packet.html#ae5a9987122def9cf9e3973173cb8df87" title="Return the packet&#39;s tailroom. ">tailroom()</a> in the current packet, or if the current packet is <a class="el" href="class_packet.html#aba191909862d94edefb19d4b5f548cf7" title="Test whether this packet&#39;s data is shared. ">shared()</a>. If no copy is made, this operation is quite efficient.</p>
<p>If a data copy would be required, but the copy fails because of lack of memory, then the current packet is freed.</p>
<p><a class="el" href="class_packet.html#a2d977927daa81b1b26607ebd4d3dde6c" title="Add space for data after the packet. ">put()</a> is usually used like this: </p>
<div class="fragment"><div class="line"><a class="code" href="class_writable_packet.html">WritablePacket</a> *q = p-&gt;<a class="code" href="class_packet.html#a2d977927daa81b1b26607ebd4d3dde6c">put</a>(100);</div>
<div class="line"><span class="keywordflow">if</span> (!q)</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="comment">// p must not be used here.</span></div>
</div><!-- fragment --><dl class="section post"><dt>Postcondition</dt><dd>new <a class="el" href="class_packet.html#a70d251ee2af3e1acacbd5026e264ca34" title="Return the packet&#39;s length. ">length()</a> == old <a class="el" href="class_packet.html#a70d251ee2af3e1acacbd5026e264ca34" title="Return the packet&#39;s length. ">length()</a> + <em>len</em> (if no failure)</dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#adbd9c1423e78e95ccba6fb5cbc27095a" title="Add space for data after the packet. ">nonunique_put</a>, <a class="el" href="class_packet.html#abdff7a45566ae198c9ed246707d5317f" title="Remove space from the end of the packet. ">take</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adbd9c1423e78e95ccba6fb5cbc27095a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_packet.html">Packet</a> * Packet::nonunique_put </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add space for data after the packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>amount of space to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>packet with added trailer space, or null on failure</dd></dl>
<p>This is a variant of <a class="el" href="class_packet.html#a2d977927daa81b1b26607ebd4d3dde6c" title="Add space for data after the packet. ">put()</a>. Returns a packet with an additional <em>len</em> bytes of uninitialized space after the current packet's data (starting at <a class="el" href="class_packet.html#a0e09d33c102240db56b2a43f30c1886d" title="Return the packet&#39;s end data pointer. ">end_data()</a>). A copy of the packet data is made if there isn't enough <a class="el" href="class_packet.html#ae5a9987122def9cf9e3973173cb8df87" title="Return the packet&#39;s tailroom. ">tailroom()</a> in the current packet. However, no copy is made if the current packet is shared; and if no copy is made, this operation is quite efficient.</p>
<p>If a data copy would be required, but the copy fails because of lack of memory, then the current packet is freed.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#a2d977927daa81b1b26607ebd4d3dde6c" title="Add space for data after the packet. ">put</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abdff7a45566ae198c9ed246707d5317f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::take </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove space from the end of the packet. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>amount of space to remove</td></tr>
  </table>
  </dd>
</dl>
<p>Removes <em>len</em> bytes from the end of the packet. This operation is efficient: it just bumps a pointer.</p>
<p>It is an error to attempt to pull more than <a class="el" href="class_packet.html#a70d251ee2af3e1acacbd5026e264ca34" title="Return the packet&#39;s length. ">length()</a> bytes.</p>
<dl class="section post"><dt>Postcondition</dt><dd>new <a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">data()</a> == old <a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">data()</a> </dd>
<dd>
new <a class="el" href="class_packet.html#a0e09d33c102240db56b2a43f30c1886d" title="Return the packet&#39;s end data pointer. ">end_data()</a> == old <a class="el" href="class_packet.html#a0e09d33c102240db56b2a43f30c1886d" title="Return the packet&#39;s end data pointer. ">end_data()</a> - <em>len</em> </dd>
<dd>
new <a class="el" href="class_packet.html#a70d251ee2af3e1acacbd5026e264ca34" title="Return the packet&#39;s length. ">length()</a> == old <a class="el" href="class_packet.html#a70d251ee2af3e1acacbd5026e264ca34" title="Return the packet&#39;s length. ">length()</a> - <em>len</em> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#a65f07d2050c0eac6625e271c6d3398ea" title="Add space for a header before the packet. ">push</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a71d4a911a16c615599137bea2f56318f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_packet.html">Packet</a> * Packet::shift_data </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>free_on_failure</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shift packet data within the data buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>amount to shift packet data </td></tr>
    <tr><td class="paramname">free_on_failure</td><td>if true, then delete the input packet on failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a packet with shifted data, or null on failure</dd></dl>
<p>Useful to align packet data. For example, if the packet's embedded IP header is located at pointer value 0x8CCA03, then shift_data(1) or shift_data(-3) will both align the header on a 4-byte boundary.</p>
<p>If the packet is <a class="el" href="class_packet.html#aba191909862d94edefb19d4b5f548cf7" title="Test whether this packet&#39;s data is shared. ">shared()</a> or there isn't enough headroom or tailroom for the operation, the packet is passed to <a class="el" href="class_packet.html#a6fcf41ec1dd9ad25d59776d1bab983a3" title="Return an unshared packet containing this packet&#39;s data. ">uniqueify()</a> first. This can fail if there isn't enough memory. If it fails, shift_data returns null, and if <em>free_on_failure</em> is true (the default), the input packet is freed.</p>
<p>The packet's mac_header, network_header, and transport_header areas are preserved, even if they lie within the headroom. Any headroom outside these regions may be overwritten, as may any tailroom.</p>
<dl class="section post"><dt>Postcondition</dt><dd>new <a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">data()</a> == old <a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">data()</a> + <em>offset</em> (if no copy is made) </dd>
<dd>
new <a class="el" href="class_packet.html#adbe89b8828541d410cb31ee2145e7a8c" title="Return a pointer to the packet&#39;s data buffer. ">buffer()</a> == old <a class="el" href="class_packet.html#adbe89b8828541d410cb31ee2145e7a8c" title="Return a pointer to the packet&#39;s data buffer. ">buffer()</a> (if no copy is made) </dd></dl>

</div>
</div>
<a class="anchor" id="a0b816dbdc37314f566917a840c2bdf29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::shrink_data </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shrink the packet's data. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>new data pointer </td></tr>
    <tr><td class="paramname">length</td><td>new length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is useful only in special contexts. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only available at user level</dd></dl>
<p>User-level programs that read packet logs commonly read a large chunk of data (32 kB or more) into a base <a class="el" href="class_packet.html" title="A network packet. ">Packet</a> object. The log reader then works over the data buffer and, for each packet contained therein, outputs a clone that shares memory with the base packet. This is space- and time-efficient, but the generated packets have gigantic headroom and tailroom. Uniqueifying a generated packet will wastefully copy this headroom and tailroom as well. The shrink_data function addresses this problem.</p>
<p><a class="el" href="class_packet.html#a0b816dbdc37314f566917a840c2bdf29" title="Shrink the packet&#39;s data. ">shrink_data()</a> removes all of a packet's headroom and tailroom. The resulting packet has <a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">data()</a> equal to <em>data</em>, <a class="el" href="class_packet.html#a70d251ee2af3e1acacbd5026e264ca34" title="Return the packet&#39;s length. ">length()</a> equal to <em>length</em>, and <a class="el" href="class_packet.html#a1c32d409a895a910bf053e31553dc5a7" title="Return the packet&#39;s headroom. ">headroom()</a> and <a class="el" href="class_packet.html#ae5a9987122def9cf9e3973173cb8df87" title="Return the packet&#39;s tailroom. ">tailroom()</a> equal to zero.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The packet <em>must</em> be a <a class="el" href="class_packet.html#aa274049bd162e38785c514fa512c44e8" title="Create a clone of this packet. ">clone()</a> of another existing packet. </dd>
<dd>
<em>data</em> &gt;= <a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">data()</a>, <em>data</em> &lt;= <a class="el" href="class_packet.html#a0e09d33c102240db56b2a43f30c1886d" title="Return the packet&#39;s end data pointer. ">end_data()</a>, <em>data</em> + <em>length</em> &gt;= <a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">data()</a>, and <em>data</em> + <em>length</em> &lt;= <a class="el" href="class_packet.html#a0e09d33c102240db56b2a43f30c1886d" title="Return the packet&#39;s end data pointer. ">end_data()</a></dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#a823d5f220d1c6bf58aff94a22a6acde7" title="Shift the packet&#39;s data view to a different part of its buffer. ">change_headroom_and_length</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a823d5f220d1c6bf58aff94a22a6acde7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::change_headroom_and_length </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>headroom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shift the packet's data view to a different part of its buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">headroom</td><td>new headroom </td></tr>
    <tr><td class="paramname">length</td><td>new length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function is useful only in special contexts. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Only available at user level</dd></dl>
<p>Shifts the packet's <a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">data()</a> pointer to a different part of the packet's data buffer. The buffer pointer itself is not changed, and the packet's contents are not affected (except by the new view).</p>
<dl class="section pre"><dt>Precondition</dt><dd><em>headroom</em> + <em>length</em> &lt;= <a class="el" href="class_packet.html#afb06d9a3645eb12d16e04008aead92f6" title="Return the packet&#39;s buffer length. ">buffer_length()</a> </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>new <a class="el" href="class_packet.html#adbe89b8828541d410cb31ee2145e7a8c" title="Return a pointer to the packet&#39;s data buffer. ">buffer()</a> == old <a class="el" href="class_packet.html#adbe89b8828541d410cb31ee2145e7a8c" title="Return a pointer to the packet&#39;s data buffer. ">buffer()</a> </dd>
<dd>
new <a class="el" href="class_packet.html#a7b4556d1300bb7a95e23b6657294714d" title="Return the packet&#39;s end data buffer pointer. ">end_buffer()</a> == old <a class="el" href="class_packet.html#a7b4556d1300bb7a95e23b6657294714d" title="Return the packet&#39;s end data buffer pointer. ">end_buffer()</a> </dd>
<dd>
new <a class="el" href="class_packet.html#a1c32d409a895a910bf053e31553dc5a7" title="Return the packet&#39;s headroom. ">headroom()</a> == <em>headroom</em> </dd>
<dd>
new <a class="el" href="class_packet.html#a70d251ee2af3e1acacbd5026e264ca34" title="Return the packet&#39;s length. ">length()</a> == <em>length</em> </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#a0b816dbdc37314f566917a840c2bdf29" title="Shrink the packet&#39;s data. ">shrink_data</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adc493cf317d2bbbcdb891b124068d9cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>headroom</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the content and annotations of another packet (userlevel). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>packet </td></tr>
    <tr><td class="paramname">headroom</td><td>for the new packet </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5c2586fa612b3892fc0e2a7616285cdf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::has_mac_header </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true iff the packet's MAC header pointer is set. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#a228aa94d61f826f5020917375d39d05d" title="Set the MAC header pointer. ">set_mac_header</a>, <a class="el" href="class_packet.html#ac42131142404795b50a9380ef64a2f52" title="Unset the MAC header pointer. ">clear_mac_header</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7a46d73a893a368c39f62e2c1a2b79d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char * Packet::mac_header </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the packet's MAC header pointer. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not useful if !has_mac_header(). </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#a63787c8b422b022b8724f78d7ac8da39" title="Return the packet&#39;s MAC header pointer as Ethernet. ">ether_header</a>, <a class="el" href="class_packet.html#a228aa94d61f826f5020917375d39d05d" title="Set the MAC header pointer. ">set_mac_header</a>, <a class="el" href="class_packet.html#ac42131142404795b50a9380ef64a2f52" title="Unset the MAC header pointer. ">clear_mac_header</a>, <a class="el" href="class_packet.html#a87805cecf70e93f7a12faf67996825e2" title="Return the MAC header length. ">mac_header_length</a>, <a class="el" href="class_packet.html#ae5274ed03ef428275f8b273600d7ee50" title="Return the packet&#39;s length starting from its MAC header pointer. ">mac_length</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a16d9ef137618c8d8ff0b3e451622df4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Packet::mac_header_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the offset from the packet data to the MAC header. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_packet.html#a7a46d73a893a368c39f62e2c1a2b79d4" title="Return the packet&#39;s MAC header pointer. ">mac_header()</a> - <a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">data()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not useful if !has_mac_header(). </dd></dl>

</div>
</div>
<a class="anchor" id="a87805cecf70e93f7a12faf67996825e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Packet::mac_header_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the MAC header length. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_packet.html#afd294846a5129344ed35071c277b5ceb" title="Return the packet&#39;s network header pointer. ">network_header()</a> - <a class="el" href="class_packet.html#a7a46d73a893a368c39f62e2c1a2b79d4" title="Return the packet&#39;s MAC header pointer. ">mac_header()</a></dd></dl>
<p>This equals the offset from the MAC header pointer to the network header pointer. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not useful if !has_mac_header() or !has_network_header(). </dd></dl>

</div>
</div>
<a class="anchor" id="ae5274ed03ef428275f8b273600d7ee50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Packet::mac_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the packet's length starting from its MAC header pointer. </p>
<dl class="section invariant"><dt>Invariant</dt><dd><a class="el" href="class_packet.html#ae5274ed03ef428275f8b273600d7ee50" title="Return the packet&#39;s length starting from its MAC header pointer. ">mac_length()</a> == <a class="el" href="class_packet.html#a0e09d33c102240db56b2a43f30c1886d" title="Return the packet&#39;s end data pointer. ">end_data()</a> - <a class="el" href="class_packet.html#a7a46d73a893a368c39f62e2c1a2b79d4" title="Return the packet&#39;s MAC header pointer. ">mac_header()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not useful if !has_mac_header(). </dd></dl>

</div>
</div>
<a class="anchor" id="a228aa94d61f826f5020917375d39d05d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::set_mac_header </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the MAC header pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>new header pointer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae5e157394f26c42592326a260ed71b3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::set_mac_header </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the MAC and network header pointers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>new MAC header pointer </td></tr>
    <tr><td class="paramname">len</td><td>new MAC header length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="class_packet.html#a7a46d73a893a368c39f62e2c1a2b79d4" title="Return the packet&#39;s MAC header pointer. ">mac_header()</a> == <em>p</em> and <a class="el" href="class_packet.html#afd294846a5129344ed35071c277b5ceb" title="Return the packet&#39;s network header pointer. ">network_header()</a> == <em>p</em> + <em>len</em> </dd></dl>

</div>
</div>
<a class="anchor" id="ac42131142404795b50a9380ef64a2f52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::clear_mac_header </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unset the MAC header pointer. </p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="class_packet.html#a5c2586fa612b3892fc0e2a7616285cdf" title="Return true iff the packet&#39;s MAC header pointer is set. ">has_mac_header()</a> == false Does not affect the network or transport header pointers. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d5062b798be9675617c84c0378a5922"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::has_network_header </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true iff the packet's network header pointer is set. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#a8ccedb02f5578da3861441b82fd88016" title="Set the network and transport header pointers. ">set_network_header</a>, <a class="el" href="class_packet.html#aed60e9f27d01d4065d00ed50295338cc" title="Unset the network header pointer. ">clear_network_header</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afd294846a5129344ed35071c277b5ceb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char * Packet::network_header </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the packet's network header pointer. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not useful if !has_network_header(). </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#a021870cf51b52aa40f3861affa9a1357" title="Return the packet&#39;s network header pointer as IPv4. ">ip_header</a>, <a class="el" href="class_packet.html#a75902c66131a3b3a1433083bce457c8d" title="Return the packet&#39;s network header pointer as IPv6. ">ip6_header</a>, <a class="el" href="class_packet.html#a8ccedb02f5578da3861441b82fd88016" title="Set the network and transport header pointers. ">set_network_header</a>, <a class="el" href="class_packet.html#aed60e9f27d01d4065d00ed50295338cc" title="Unset the network header pointer. ">clear_network_header</a>, <a class="el" href="class_packet.html#a4513c30a56c8519f59a65b33db9dea0e" title="Return the network header length. ">network_header_length</a>, <a class="el" href="class_packet.html#a9d9b046094ac828fa5814ced48ab15e3" title="Return the packet&#39;s length starting from its network header pointer. ">network_length</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9daaf4f69b8091b52520bae57a9203b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Packet::network_header_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the offset from the packet data to the network header. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_packet.html#afd294846a5129344ed35071c277b5ceb" title="Return the packet&#39;s network header pointer. ">network_header()</a> - <a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">data()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not useful if !has_network_header(). </dd></dl>

</div>
</div>
<a class="anchor" id="a4513c30a56c8519f59a65b33db9dea0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Packet::network_header_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the network header length. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_packet.html#aab05b59f5c8e4bbea2ffa8d6d1ad31e7" title="Return the packet&#39;s transport header pointer. ">transport_header()</a> - <a class="el" href="class_packet.html#afd294846a5129344ed35071c277b5ceb" title="Return the packet&#39;s network header pointer. ">network_header()</a></dd></dl>
<p>This equals the offset from the network header pointer to the transport header pointer. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not useful if !has_network_header() or !has_transport_header(). </dd></dl>

</div>
</div>
<a class="anchor" id="a9d9b046094ac828fa5814ced48ab15e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Packet::network_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the packet's length starting from its network header pointer. </p>
<dl class="section invariant"><dt>Invariant</dt><dd><a class="el" href="class_packet.html#a9d9b046094ac828fa5814ced48ab15e3" title="Return the packet&#39;s length starting from its network header pointer. ">network_length()</a> == <a class="el" href="class_packet.html#a0e09d33c102240db56b2a43f30c1886d" title="Return the packet&#39;s end data pointer. ">end_data()</a> - <a class="el" href="class_packet.html#afd294846a5129344ed35071c277b5ceb" title="Return the packet&#39;s network header pointer. ">network_header()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not useful if !has_network_header(). </dd></dl>

</div>
</div>
<a class="anchor" id="a8ccedb02f5578da3861441b82fd88016"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::set_network_header </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the network and transport header pointers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>new network header pointer </td></tr>
    <tr><td class="paramname">len</td><td>new network header length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="class_packet.html#afd294846a5129344ed35071c277b5ceb" title="Return the packet&#39;s network header pointer. ">network_header()</a> == <em>p</em> and <a class="el" href="class_packet.html#aab05b59f5c8e4bbea2ffa8d6d1ad31e7" title="Return the packet&#39;s transport header pointer. ">transport_header()</a> == <em>p</em> + <em>len</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a80231c68fa6df0368e7611c9da726296"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::set_network_header_length </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the network header length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>new network header length</td></tr>
  </table>
  </dd>
</dl>
<p>Setting the network header length really just sets the transport header pointer. </p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="class_packet.html#aab05b59f5c8e4bbea2ffa8d6d1ad31e7" title="Return the packet&#39;s transport header pointer. ">transport_header()</a> == <a class="el" href="class_packet.html#afd294846a5129344ed35071c277b5ceb" title="Return the packet&#39;s network header pointer. ">network_header()</a> + <em>len</em> </dd></dl>

</div>
</div>
<a class="anchor" id="aed60e9f27d01d4065d00ed50295338cc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::clear_network_header </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unset the network header pointer. </p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="class_packet.html#a2d5062b798be9675617c84c0378a5922" title="Return true iff the packet&#39;s network header pointer is set. ">has_network_header()</a> == false Does not affect the MAC or transport header pointers. </dd></dl>

</div>
</div>
<a class="anchor" id="a05f74f71d6f729673744e71402980b4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Packet::has_transport_header </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true iff the packet's network header pointer is set. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#a8ccedb02f5578da3861441b82fd88016" title="Set the network and transport header pointers. ">set_network_header</a>, <a class="el" href="class_packet.html#a0eebe7b89b411906d088926a90fbafa0" title="Unset the transport header pointer. ">clear_transport_header</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aab05b59f5c8e4bbea2ffa8d6d1ad31e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char * Packet::transport_header </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the packet's transport header pointer. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not useful if !has_transport_header(). </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#a4c5a9e2050051a83959f6905d68d5099" title="Return the packet&#39;s transport header pointer as TCP. ">tcp_header</a>, <a class="el" href="class_packet.html#a4f29ae68c1bd946ce43c3ffc625a296e" title="Return the packet&#39;s transport header pointer as UDP. ">udp_header</a>, <a class="el" href="class_packet.html#a9d2083716e975dffedeb68af28e9c98c" title="Return the packet&#39;s transport header pointer as ICMP. ">icmp_header</a>, set_transport_header, <a class="el" href="class_packet.html#a0eebe7b89b411906d088926a90fbafa0" title="Unset the transport header pointer. ">clear_transport_header</a>, <a class="el" href="class_packet.html#a8574b7f2b5141dc8ec2d8372eb8f74d6" title="Return the packet&#39;s length starting from its transport header pointer. ">transport_length</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a955d3c26b868477e094c3eb3d46a0e7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Packet::transport_header_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the offset from the packet data to the transport header. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_packet.html#aab05b59f5c8e4bbea2ffa8d6d1ad31e7" title="Return the packet&#39;s transport header pointer. ">transport_header()</a> - <a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">data()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not useful if !has_transport_header(). </dd></dl>

</div>
</div>
<a class="anchor" id="a8574b7f2b5141dc8ec2d8372eb8f74d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Packet::transport_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the packet's length starting from its transport header pointer. </p>
<dl class="section invariant"><dt>Invariant</dt><dd><a class="el" href="class_packet.html#a8574b7f2b5141dc8ec2d8372eb8f74d6" title="Return the packet&#39;s length starting from its transport header pointer. ">transport_length()</a> == <a class="el" href="class_packet.html#a0e09d33c102240db56b2a43f30c1886d" title="Return the packet&#39;s end data pointer. ">end_data()</a> - <a class="el" href="class_packet.html#aab05b59f5c8e4bbea2ffa8d6d1ad31e7" title="Return the packet&#39;s transport header pointer. ">transport_header()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not useful if !has_transport_header(). </dd></dl>

</div>
</div>
<a class="anchor" id="a0eebe7b89b411906d088926a90fbafa0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::clear_transport_header </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unset the transport header pointer. </p>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="class_packet.html#a05f74f71d6f729673744e71402980b4f" title="Return true iff the packet&#39;s network header pointer is set. ">has_transport_header()</a> == false Does not affect the MAC or network header pointers. </dd></dl>

</div>
</div>
<a class="anchor" id="a63787c8b422b022b8724f78d7ac8da39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const click_ether * Packet::ether_header </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the packet's MAC header pointer as Ethernet. </p>
<dl class="section invariant"><dt>Invariant</dt><dd>(void *) <a class="el" href="class_packet.html#a63787c8b422b022b8724f78d7ac8da39" title="Return the packet&#39;s MAC header pointer as Ethernet. ">ether_header()</a> == (void *) <a class="el" href="class_packet.html#a7a46d73a893a368c39f62e2c1a2b79d4" title="Return the packet&#39;s MAC header pointer. ">mac_header()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not useful if !has_mac_header(). </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#a7a46d73a893a368c39f62e2c1a2b79d4" title="Return the packet&#39;s MAC header pointer. ">mac_header</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a76af9e95e57d5c3f728959d52a5a211f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::set_ether_header </td>
          <td>(</td>
          <td class="paramtype">const click_ether *&#160;</td>
          <td class="paramname"><em>ethh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the MAC header pointer to an Ethernet header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ethh</td><td>new Ethernet header pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>(void *) <a class="el" href="class_packet.html#a7a46d73a893a368c39f62e2c1a2b79d4" title="Return the packet&#39;s MAC header pointer. ">mac_header()</a> == (void *) <em>ethh</em> </dd>
<dd>
<a class="el" href="class_packet.html#a87805cecf70e93f7a12faf67996825e2" title="Return the MAC header length. ">mac_header_length()</a> == 14 </dd>
<dd>
(void *) <a class="el" href="class_packet.html#afd294846a5129344ed35071c277b5ceb" title="Return the packet&#39;s network header pointer. ">network_header()</a> == (void *) (<em>ethh</em> + 1) </dd></dl>

</div>
</div>
<a class="anchor" id="a021870cf51b52aa40f3861affa9a1357"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const click_ip * Packet::ip_header </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the packet's network header pointer as IPv4. </p>
<dl class="section invariant"><dt>Invariant</dt><dd>(void *) <a class="el" href="class_packet.html#a021870cf51b52aa40f3861affa9a1357" title="Return the packet&#39;s network header pointer as IPv4. ">ip_header()</a> == (void *) <a class="el" href="class_packet.html#afd294846a5129344ed35071c277b5ceb" title="Return the packet&#39;s network header pointer. ">network_header()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not useful if !has_network_header(). </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#afd294846a5129344ed35071c277b5ceb" title="Return the packet&#39;s network header pointer. ">network_header</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac386ae82a577f4bef622dcbc6d23915d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Packet::ip_header_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the offset from the packet data to the IP header. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_packet.html#afd294846a5129344ed35071c277b5ceb" title="Return the packet&#39;s network header pointer. ">network_header()</a> - <a class="el" href="class_packet.html#a7a46d73a893a368c39f62e2c1a2b79d4" title="Return the packet&#39;s MAC header pointer. ">mac_header()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not useful if !has_network_header(). </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#a9daaf4f69b8091b52520bae57a9203b8" title="Return the offset from the packet data to the network header. ">network_header_offset</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad1ee6106632e47fd37cc08c70f27a1a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Packet::ip_header_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the IP header length. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_packet.html#aab05b59f5c8e4bbea2ffa8d6d1ad31e7" title="Return the packet&#39;s transport header pointer. ">transport_header()</a> - <a class="el" href="class_packet.html#afd294846a5129344ed35071c277b5ceb" title="Return the packet&#39;s network header pointer. ">network_header()</a></dd></dl>
<p>This equals the offset from the network header pointer to the transport header pointer. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not useful if !has_network_header() or !has_transport_header(). </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#a4513c30a56c8519f59a65b33db9dea0e" title="Return the network header length. ">network_header_length</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac533aeeadb580ba67dbc9c3e5394aecd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::set_ip_header </td>
          <td>(</td>
          <td class="paramtype">const click_ip *&#160;</td>
          <td class="paramname"><em>iph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the network header pointer to an IPv4 header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iph</td><td>new IP header pointer </td></tr>
    <tr><td class="paramname">len</td><td>new IP header length in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>(char *) <a class="el" href="class_packet.html#afd294846a5129344ed35071c277b5ceb" title="Return the packet&#39;s network header pointer. ">network_header()</a> == (char *) <em>iph</em> </dd>
<dd>
<a class="el" href="class_packet.html#a4513c30a56c8519f59a65b33db9dea0e" title="Return the network header length. ">network_header_length()</a> == <em>len</em> </dd>
<dd>
(char *) <a class="el" href="class_packet.html#aab05b59f5c8e4bbea2ffa8d6d1ad31e7" title="Return the packet&#39;s transport header pointer. ">transport_header()</a> == (char *) <em>iph</em> + <em>len</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a75902c66131a3b3a1433083bce457c8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const click_ip6 * Packet::ip6_header </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the packet's network header pointer as IPv6. </p>
<dl class="section invariant"><dt>Invariant</dt><dd>(void *) <a class="el" href="class_packet.html#a75902c66131a3b3a1433083bce457c8d" title="Return the packet&#39;s network header pointer as IPv6. ">ip6_header()</a> == (void *) <a class="el" href="class_packet.html#afd294846a5129344ed35071c277b5ceb" title="Return the packet&#39;s network header pointer. ">network_header()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not useful if !has_network_header(). </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#afd294846a5129344ed35071c277b5ceb" title="Return the packet&#39;s network header pointer. ">network_header</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac602c7113bc503d2137e7fc2629c5020"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Packet::ip6_header_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the offset from the packet data to the IPv6 header. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_packet.html#afd294846a5129344ed35071c277b5ceb" title="Return the packet&#39;s network header pointer. ">network_header()</a> - <a class="el" href="class_packet.html#a547fb52b84a4e9a74bd1f4599665098b" title="Return the packet&#39;s data pointer. ">data()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not useful if !has_network_header(). </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#a9daaf4f69b8091b52520bae57a9203b8" title="Return the offset from the packet data to the network header. ">network_header_offset</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abbcdbc796e6348f0f489b68c8cd287cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Packet::ip6_header_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the IPv6 header length. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_packet.html#aab05b59f5c8e4bbea2ffa8d6d1ad31e7" title="Return the packet&#39;s transport header pointer. ">transport_header()</a> - <a class="el" href="class_packet.html#afd294846a5129344ed35071c277b5ceb" title="Return the packet&#39;s network header pointer. ">network_header()</a></dd></dl>
<p>This equals the offset from the network header pointer to the transport header pointer. </p>
<dl class="section warning"><dt>Warning</dt><dd>Not useful if !has_network_header() or !has_transport_header(). </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#a4513c30a56c8519f59a65b33db9dea0e" title="Return the network header length. ">network_header_length</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0c16b5583c5e8011c631143d3ca92439"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::set_ip6_header </td>
          <td>(</td>
          <td class="paramtype">const click_ip6 *&#160;</td>
          <td class="paramname"><em>ip6h</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the network header pointer to an IPv6 header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip6h</td><td>new IP header pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>(char *) <a class="el" href="class_packet.html#afd294846a5129344ed35071c277b5ceb" title="Return the packet&#39;s network header pointer. ">network_header()</a> == (char *) <em>ip6h</em> </dd>
<dd>
<a class="el" href="class_packet.html#a4513c30a56c8519f59a65b33db9dea0e" title="Return the network header length. ">network_header_length()</a> == 40 </dd>
<dd>
(char *) <a class="el" href="class_packet.html#aab05b59f5c8e4bbea2ffa8d6d1ad31e7" title="Return the packet&#39;s transport header pointer. ">transport_header()</a> == (char *) (<em>ip6h</em> + 1) </dd></dl>

</div>
</div>
<a class="anchor" id="a885abc2d81b92d4c04779a6f8ff4db0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::set_ip6_header </td>
          <td>(</td>
          <td class="paramtype">const click_ip6 *&#160;</td>
          <td class="paramname"><em>ip6h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the network header pointer to an IPv6 header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ip6h</td><td>new IP header pointer </td></tr>
    <tr><td class="paramname">len</td><td>new IP header length in bytes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd>(char *) <a class="el" href="class_packet.html#afd294846a5129344ed35071c277b5ceb" title="Return the packet&#39;s network header pointer. ">network_header()</a> == (char *) <em>ip6h</em> </dd>
<dd>
<a class="el" href="class_packet.html#a4513c30a56c8519f59a65b33db9dea0e" title="Return the network header length. ">network_header_length()</a> == <em>len</em> </dd>
<dd>
(char *) <a class="el" href="class_packet.html#aab05b59f5c8e4bbea2ffa8d6d1ad31e7" title="Return the packet&#39;s transport header pointer. ">transport_header()</a> == (char *) <em>ip6h</em> + <em>len</em> </dd></dl>

</div>
</div>
<a class="anchor" id="a9d2083716e975dffedeb68af28e9c98c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const click_icmp * Packet::icmp_header </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the packet's transport header pointer as ICMP. </p>
<dl class="section invariant"><dt>Invariant</dt><dd>(void *) <a class="el" href="class_packet.html#a9d2083716e975dffedeb68af28e9c98c" title="Return the packet&#39;s transport header pointer as ICMP. ">icmp_header()</a> == (void *) <a class="el" href="class_packet.html#aab05b59f5c8e4bbea2ffa8d6d1ad31e7" title="Return the packet&#39;s transport header pointer. ">transport_header()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not useful if !has_transport_header(). </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#aab05b59f5c8e4bbea2ffa8d6d1ad31e7" title="Return the packet&#39;s transport header pointer. ">transport_header</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4c5a9e2050051a83959f6905d68d5099"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const click_tcp * Packet::tcp_header </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the packet's transport header pointer as TCP. </p>
<dl class="section invariant"><dt>Invariant</dt><dd>(void *) <a class="el" href="class_packet.html#a4c5a9e2050051a83959f6905d68d5099" title="Return the packet&#39;s transport header pointer as TCP. ">tcp_header()</a> == (void *) <a class="el" href="class_packet.html#aab05b59f5c8e4bbea2ffa8d6d1ad31e7" title="Return the packet&#39;s transport header pointer. ">transport_header()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not useful if !has_transport_header(). </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#aab05b59f5c8e4bbea2ffa8d6d1ad31e7" title="Return the packet&#39;s transport header pointer. ">transport_header</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4f29ae68c1bd946ce43c3ffc625a296e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const click_udp * Packet::udp_header </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the packet's transport header pointer as UDP. </p>
<dl class="section invariant"><dt>Invariant</dt><dd>(void *) <a class="el" href="class_packet.html#a4f29ae68c1bd946ce43c3ffc625a296e" title="Return the packet&#39;s transport header pointer as UDP. ">udp_header()</a> == (void *) <a class="el" href="class_packet.html#aab05b59f5c8e4bbea2ffa8d6d1ad31e7" title="Return the packet&#39;s transport header pointer. ">transport_header()</a> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Not useful if !has_transport_header(). </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="class_packet.html#aab05b59f5c8e4bbea2ffa8d6d1ad31e7" title="Return the packet&#39;s transport header pointer. ">transport_header</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7d1236d9a4fa528c65bebf98c1fb1de5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structclick__dns.html">click_dns</a> * Packet::dns_header </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the packet's dns header pointer as DNS. </p>

</div>
</div>
<a class="anchor" id="abd060f963d8c4ef9dedad91af9f19841"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_timestamp.html">Timestamp</a> &amp; Packet::timestamp_anno </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the timestamp annotation. </p>

</div>
</div>
<a class="anchor" id="ab6760687354019bab34761317f0f3fb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_timestamp.html">Timestamp</a> &amp; Packet::timestamp_anno </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="af50f64d25d2640626d1923bd40db2dde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::set_timestamp_anno </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_timestamp.html">Timestamp</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the timestamp annotation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>new timestamp </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1f6ca54977ec5676e78d506c50f3a53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">net_device * Packet::device_anno </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the device annotation. </p>

</div>
</div>
<a class="anchor" id="a9086298fc1806d6b6194bf047c4e11a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::set_device_anno </td>
          <td>(</td>
          <td class="paramtype">net_device *&#160;</td>
          <td class="paramname"><em>dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the device annotation. </p>

</div>
</div>
<a class="anchor" id="ac56ee973f22d65c9a2c7b20df7de3035"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_packet.html#a99d687a19a8f94b7625c57a809c9f65b">Packet::PacketType</a> Packet::packet_type_anno </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the packet type annotation. </p>

</div>
</div>
<a class="anchor" id="ae7ce6541f8c20d59c9967ef21202ebd0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::set_packet_type_anno </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_packet.html#a99d687a19a8f94b7625c57a809c9f65b">PacketType</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the packet type annotation. </p>

</div>
</div>
<a class="anchor" id="a87cf4d128d13182b033c2ee24fb6672c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_packet.html">Packet</a> * Packet::next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the next packet annotation. </p>

</div>
</div>
<a class="anchor" id="af4f936c442fa8a3fd3b4fc61d8974680"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_packet.html">Packet</a> *&amp; Packet::next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a50653ef20efbbe7a6715e08bf76434bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::set_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the next packet annotation. </p>

</div>
</div>
<a class="anchor" id="a8e6f958dc910af7a8ae22c562cd8bca5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_packet.html">Packet</a> * Packet::prev </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the previous packet annotation. </p>

</div>
</div>
<a class="anchor" id="abf786dbbceb56f99472bb8a81a728de8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_packet.html">Packet</a> *&amp; Packet::prev </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="af52b46102d7113e5555b6dc887fd3edf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::set_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the previous packet annotation. </p>

</div>
</div>
<a class="anchor" id="ab6d4c6488d28abea4e14ea84b90be64a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_i_p_address.html">IPAddress</a> Packet::dst_ip_anno </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the destination IPv4 address annotation. </p>
<p>The value is taken from the address annotation area. </p>

</div>
</div>
<a class="anchor" id="a3e0c2708bafb1cb661223867f2da34b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::set_dst_ip_anno </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_i_p_address.html">IPAddress</a>&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the destination IPv4 address annotation. </p>
<p>The value is stored in the address annotation area. </p>

</div>
</div>
<a class="anchor" id="a4bb62ea68b33bfc7ccb23fef5c7a4bd7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* Packet::anno </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the annotation area. </p>
<p>The area is <a class="el" href="class_packet.html#a9da06ca41f8744c66f57db271302fbbba37ffbe2ed8e612868890511c356dc4f7">anno_size </a> bytes long. </p>

</div>
</div>
<a class="anchor" id="a6c8cb59296235d8723f93f3ff89cd8cb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void* Packet::anno </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a class="anchor" id="a10f7f051482d565dd0f84e931d69958c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* Packet::anno_u8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the annotation area as uint8_ts. </p>

</div>
</div>
<a class="anchor" id="a502bc1b95701c478b180248a8a6fb9e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* Packet::anno_u8 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload </p>

</div>
</div>
<a class="anchor" id="ad91f01a28db1106cf6d8f7e331c70be8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t* Packet::anno_u32 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the annotation area as uint32_ts. </p>

</div>
</div>
<a class="anchor" id="a3cbd4be843f49b812edb9843ac0afa93"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint32_t* Packet::anno_u32 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overload </p>

</div>
</div>
<a class="anchor" id="af5f79538338891d00db65d27fc694077"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Packet::anno_u8 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return annotation byte at offset <em>i</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="class_packet.html#a9da06ca41f8744c66f57db271302fbbba37ffbe2ed8e612868890511c356dc4f7">anno_size </a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac7af380fd9ca70234b989cda231fb1dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::set_anno_u8 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set annotation byte at offset <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>annotation offset in bytes </td></tr>
    <tr><td class="paramname">x</td><td>value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="class_packet.html#a9da06ca41f8744c66f57db271302fbbba37ffbe2ed8e612868890511c356dc4f7">anno_size </a> </dd></dl>

</div>
</div>
<a class="anchor" id="abc26f612c80e38d6b6b3a89948ce37d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t Packet::anno_u16 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 16-bit annotation at offset <em>i</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="class_packet.html#a9da06ca41f8744c66f57db271302fbbba37ffbe2ed8e612868890511c356dc4f7">anno_size </a> - 1 </dd>
<dd>
On aligned targets, <em>i</em> must be evenly divisible by 2.</dd></dl>
<p>Affects annotation bytes [<em>i</em>, <em>i+1</em>]. </p>

</div>
</div>
<a class="anchor" id="a12d0258d9558db418ce435c77170402e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::set_anno_u16 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set 16-bit annotation at offset <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>annotation offset in bytes </td></tr>
    <tr><td class="paramname">x</td><td>value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="class_packet.html#a9da06ca41f8744c66f57db271302fbbba37ffbe2ed8e612868890511c356dc4f7">anno_size </a> - 1 </dd>
<dd>
On aligned targets, <em>i</em> must be evenly divisible by 2.</dd></dl>
<p>Affects annotation bytes [<em>i</em>, <em>i+1</em>]. </p>

</div>
</div>
<a class="anchor" id="a717a2e1fdf5402ffa6f811d5f5477248"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int16_t Packet::anno_s16 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 16-bit annotation at offset <em>i</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="class_packet.html#a9da06ca41f8744c66f57db271302fbbba37ffbe2ed8e612868890511c356dc4f7">anno_size </a> - 1 </dd>
<dd>
On aligned targets, <em>i</em> must be evenly divisible by 2.</dd></dl>
<p>Affects annotation bytes [<em>i</em>, <em>i+1</em>]. </p>

</div>
</div>
<a class="anchor" id="a655cf22d71a72a4d6fc61794beff1f31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::set_anno_s16 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set 16-bit annotation at offset <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>annotation offset in bytes </td></tr>
    <tr><td class="paramname">x</td><td>value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="class_packet.html#a9da06ca41f8744c66f57db271302fbbba37ffbe2ed8e612868890511c356dc4f7">anno_size </a> - 1 </dd>
<dd>
On aligned targets, <em>i</em> must be evenly divisible by 2.</dd></dl>
<p>Affects annotation bytes [<em>i</em>, <em>i+1</em>]. </p>

</div>
</div>
<a class="anchor" id="a0016128185e8c5c36fb6a0024e78be92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Packet::anno_u32 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 32-bit annotation at offset <em>i</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="class_packet.html#a9da06ca41f8744c66f57db271302fbbba37ffbe2ed8e612868890511c356dc4f7">anno_size </a> - 3 </dd>
<dd>
On aligned targets, <em>i</em> must be evenly divisible by 4.</dd></dl>
<p>Affects user annotation bytes [<em>i</em>, <em>i+3</em>]. </p>

</div>
</div>
<a class="anchor" id="a214f3cee1b33a8d003fcbca241a0c205"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::set_anno_u32 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set 32-bit annotation at offset <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>annotation offset in bytes </td></tr>
    <tr><td class="paramname">x</td><td>value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="class_packet.html#a9da06ca41f8744c66f57db271302fbbba37ffbe2ed8e612868890511c356dc4f7">anno_size </a> - 3 </dd>
<dd>
On aligned targets, <em>i</em> must be evenly divisible by 4.</dd></dl>
<p>Affects user annotation bytes [<em>i</em>, <em>i+3</em>]. </p>

</div>
</div>
<a class="anchor" id="ab02f2c5cd3e413761d75a864947d1baa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Packet::anno_s32 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 32-bit annotation at offset <em>i</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="class_packet.html#a9da06ca41f8744c66f57db271302fbbba37ffbe2ed8e612868890511c356dc4f7">anno_size </a> - 3</dd></dl>
<p>Affects user annotation bytes [4*<em>i</em>, 4*<em>i+3</em>]. </p>

</div>
</div>
<a class="anchor" id="a576e2ff60d6743bd603f8cf0bf1030dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::set_anno_s32 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set 32-bit annotation at offset <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>annotation offset in bytes </td></tr>
    <tr><td class="paramname">x</td><td>value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="class_packet.html#a9da06ca41f8744c66f57db271302fbbba37ffbe2ed8e612868890511c356dc4f7">anno_size </a> - 3 </dd>
<dd>
On aligned targets, <em>i</em> must be evenly divisible by 4.</dd></dl>
<p>Affects user annotation bytes [<em>i</em>, <em>i+3</em>]. </p>

</div>
</div>
<a class="anchor" id="ad9a75ab357039920c16cf02b136fec5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t Packet::anno_u64 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return 64-bit annotation at offset <em>i</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="class_packet.html#a9da06ca41f8744c66f57db271302fbbba37ffbe2ed8e612868890511c356dc4f7">anno_size </a> - 7 </dd>
<dd>
On aligned targets, <em>i</em> must be aligned properly for uint64_t.</dd></dl>
<p>Affects user annotation bytes [<em>i</em>, <em>i+7</em>]. </p>

</div>
</div>
<a class="anchor" id="a1fba10b6dbe02158ab17ee34355fd395"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::set_anno_u64 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set 64-bit annotation at offset <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>annotation offset in bytes </td></tr>
    <tr><td class="paramname">x</td><td>value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="class_packet.html#a9da06ca41f8744c66f57db271302fbbba37ffbe2ed8e612868890511c356dc4f7">anno_size </a> - 7 </dd>
<dd>
On aligned targets, <em>i</em> must be aligned properly for uint64_t.</dd></dl>
<p>Affects user annotation bytes [<em>i</em>, <em>i+7</em>]. </p>

</div>
</div>
<a class="anchor" id="a0d7677b7202502c016bf8bdc4b6ec9ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* Packet::anno_ptr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return void * sized annotation at offset <em>i</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="class_packet.html#a9da06ca41f8744c66f57db271302fbbba37ffbe2ed8e612868890511c356dc4f7">anno_size </a> - sizeof(void *) </dd>
<dd>
On aligned targets, <em>i</em> must be aligned properly.</dd></dl>
<p>Affects user annotation bytes [<em>i</em>, <em>i+sizeof</em>(void *)]. </p>

</div>
</div>
<a class="anchor" id="a722a3eea016326a6c1ef583afb662579"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::set_anno_ptr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set void * sized annotation at offset <em>i</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>annotation offset in bytes </td></tr>
    <tr><td class="paramname">x</td><td>value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>0 &lt;= <em>i</em> &lt; <a class="el" href="class_packet.html#a9da06ca41f8744c66f57db271302fbbba37ffbe2ed8e612868890511c356dc4f7">anno_size </a> - sizeof(void *) </dd>
<dd>
On aligned targets, <em>i</em> must be aligned properly.</dd></dl>
<p>Affects user annotation bytes [<em>i</em>, <em>i+sizeof</em>(void *)]. </p>

</div>
</div>
<a class="anchor" id="ae6e4ba859ee7ef8d4bd2561da9eb150c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::clear_annotations </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear all packet annotations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">all</td><td>If true, clear all annotations. If false, clear only Click's internal annotations.</td></tr>
  </table>
  </dd>
</dl>
<p>All user annotations and the address annotation are set to zero, the packet type annotation is set to HOST, the device annotation and all header pointers are set to null, the timestamp annotation is cleared, and the next/prev-packet annotations are set to null.</p>
<p>If <em>all</em> is false, then the packet type, device, timestamp, header, and next/prev-packet annotations are left alone. </p>

</div>
</div>
<a class="anchor" id="a7f9f660eec3b4f166763d3c54db6e3c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Packet::copy_annotations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_packet.html">Packet</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy most packet annotations from <em>p</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>source of annotations</td></tr>
  </table>
  </dd>
</dl>
<p>This packet's user annotations, address annotation, packet type annotation, device annotation, and timestamp annotation are set to the corresponding annotations from <em>p</em>.</p>
<dl class="section note"><dt>Note</dt><dd>The next/prev-packet and header annotations are not copied. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/click/<a class="el" href="packet_8hh_source.html">packet.hh</a></li>
<li>lib/packet.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jan 15 2018 22:13:46 for Click by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
