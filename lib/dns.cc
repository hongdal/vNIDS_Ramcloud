#include <click/config.h>
#include <clicknet/dns.h>
#include <click/logger.h>
#include <click/packet.hh>

#define UNUSED(expr)  \
	do                \
	{                 \
		(void)(expr); \
	} while (0)

enum
{
	STATE_ERROR = -1,
	STATE_END,
	STATE_DNS_NAME,
	STATE_DNS_TYPE,
	STATE_DNS_CLASS,
	STATE_DNS_TTL,
	STATE_DNS_RDLENGTH,
	STATE_DNS_RDATA
};

static inline void _print_in_addr(uint32_t addr)
{
	UNUSED(addr);
	LOG_DEBUG("%d.%d.%d.%d", (addr >> 24), (addr >> 16) % 256, (addr >> 8) % 256, addr % 256);
}

// TODO: read the rfc
#define MAX_LABLE_LEN 45

/** @brief DNS Question
 */
static const unsigned char *_dns_parse_queries(const unsigned char *data,
											   const unsigned char *end,
											   click_dns_info *dns_data)
{

	char buf[1024];
	const unsigned char *p = data;
	unsigned int n_oct = 0, state = STATE_DNS_NAME, i = 0;

	for (p = data; p < end && STATE_END != state; p++)
	{
		if (STATE_DNS_NAME == state)
		{
			if (*p == 0)
			{
				buf[i++] = '\0';
				// ignore first ".
				LOG_DEBUG("DNS QNAME: %s", buf + 1);
				// @note only one qname is saved
				if (!dns_data->qname)
				{
					uint32_t q_len = strlen(buf);
					dns_data->qname = new char[q_len];
					memcpy(dns_data->qname, buf + 1, q_len);
				}
				state = STATE_DNS_TYPE;
			}
			else if (n_oct == 0)
			{
				n_oct = (unsigned int)*p;
				buf[i++] = '.';
			}
			else if (n_oct && end - p > n_oct)
			{
				memcpy(buf + i, p, n_oct);
				i += n_oct;
				p += n_oct - 1;
				n_oct = 0;
			}
		}
		else
		{
			switch (state)
			{
			case STATE_DNS_TYPE:
				dns_data->dns_type = ntohs(*(uint16_t *)p);
				p += 2 - 1;
				state = STATE_DNS_CLASS;
				break;
			case STATE_DNS_CLASS:
				dns_data->dns_class = ntohs(*(uint16_t *)p);
				p += 2 - 1;
				state = STATE_END;
				break;
			}
		}
	}
	return p;
}

/** @brief DNS Resource record part 2 <br/>
 * part 1 is the same as DNS Question
 */
static const unsigned char *_dns_parse_record(const unsigned char *data,
											  const unsigned char *end,
											  click_dns_info *info)
{

	data = _dns_parse_queries(data, end, info);
	// @note ignore content if TYPE is not A or CLASS is not IN
	bool ignore = ((DNS_TYPE_A != info->dns_type) || (DNS_CLASS_IN != info->dns_class));
	unsigned int state = STATE_DNS_TTL;
	const unsigned char *p;
	uint16_t len = 0;
	uint32_t ttl;
	(void)ttl;

	for (p = data; p < end && STATE_END != state; p++)
	{
		switch (state)
		{
		case STATE_DNS_TTL:
			ttl = ntohl(*(uint32_t *)p);
			LOG_DEBUG("ttl %u", ttl);
			p += 4 - 1;
			state = STATE_DNS_RDLENGTH;
			break;
		case STATE_DNS_RDLENGTH:
			len = ntohs(*(uint16_t *)p);
			// @note ignore if len != 4
			ignore = ignore || (len != 4);
			p += 2 - 1;
			state = STATE_DNS_RDATA;
			break;
		case STATE_DNS_RDATA:
			if (ignore)
			{
				p += len - 1;
				LOG_DEBUG("ignore dns record ...");
			}
			else
			{
				info->dns_record_ip = ntohl(*(uint32_t *)p);
				LOG_DEBUG("DNSRR %u", info->dns_record_ip);
				_print_in_addr(info->dns_record_ip);
				p += 4 - 1;
			}
			state = STATE_END;
			break;
		}
	}
	return p;
}

/** @return 0 means success, other returns mean errors
 */
int dns_parse_info(const unsigned char *start,
				   const unsigned char *end,
				   const click_dns *dh,
				   click_dns_info *info)
{

	unsigned int i;
	unsigned int count;
	// @note parse then discard. Change in the future if need parse dns
	count = ntohs(dh->dh_qdcount);
	info->dns_record_ip = 0;

	for (i = 0; i < count && start < end; i++)
	{
		start = _dns_parse_queries(start, end, info);
	}
	if (start >= end)
	{
		LOG_DEBUG("no other records");
		return 0;
	}
	// @note only parse 1 answer ...
	count = ntohs(dh->dh_ancount);
	count = 1;
	for (i = 0; i < count && start < end; i++)
	{
		start = _dns_parse_record(start, end, info);
	}
	return 0;
}

/* @begin */
/*********Add code which generated by Binpac**********/
// This file is automatically generated from dns.pac.

#ifdef __clang__
#pragma clang diagnostic ignored "-Wparentheses-equality"
#endif

namespace binpac
{
namespace DNS
{
ContextDNS::ContextDNS(DNS_Conn *connection, DNS_Flow *flow)
{
	connection_ = connection;
	flow_ = flow;
}

ContextDNS::~ContextDNS()
{
}

DNS_Conn::DNS_Conn(click_dns_info *info)
{
	upflow_ = new DNS_Flow(this, true);
	downflow_ = new DNS_Flow(this, false);
	info_ = info;
}

DNS_Conn::~DNS_Conn()
{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
}

void DNS_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
{
	if (is_orig)
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
}

void DNS_Conn::NewGap(bool is_orig, int gap_length)
{
	if (is_orig)
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
}

void DNS_Conn::FlowEOF(bool is_orig)
{
	if (is_orig)
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
}

DNS_PDU::DNS_PDU(bool is_orig)
{
	val_case_index_ = -1;
	request_ = 0;
	response_ = 0;
	is_orig_ = is_orig;
}

DNS_PDU::~DNS_PDU()
{
	switch (val_case_index())
	{
	case 1:
		// Clean up "request"
		{
			delete request_;
			request_ = 0;
		}
		break;
	case 0:
		// Clean up "response"
		{
			delete response_;
			response_ = 0;
		}
		break;
	}
}

int DNS_PDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNS *t_context)
{
	int t_val__size;
	val_case_index_ = is_orig();
	switch (val_case_index())
	{
	case 1:
		// Parse "request"
		{
			request_ = new DNS_message();
			int t_request__size;
			t_request__size = request_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_request__size;
		}
		break;
	case 0:
		// Parse "response"
		{
			response_ = new DNS_message();
			int t_response__size;
			t_response__size = response_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_response__size;
		}
		break;
	default:
		throw binpac::ExceptionInvalidCaseIndex("DNS_PDU", val_case_index());
		break;
	}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
}

DNS_message::DNS_message()
{
	header_ = 0;
	question_ = 0;
	question__elem_ = 0;
	answer_ = 0;
	answer__elem_ = 0;
	authority_ = 0;
	authority__elem_ = 0;
	additional_ = 0;
	additional__elem_ = 0;
	byteorder_ = bigendian;
}

DNS_message::~DNS_message()
{
	delete header_;
	header_ = 0;
	delete question__elem_;
	question__elem_ = 0;
	if (question())
	{
		for (int i = 0; i < (int)question()->size(); ++i)
		{
			DNS_question *question__elem_ = (*question_)[i];
			delete question__elem_;
			question__elem_ = 0;
		}
	}
	delete question_;
	delete answer__elem_;
	answer__elem_ = 0;
	if (answer())
	{
		for (int i = 0; i < (int)answer()->size(); ++i)
		{
			DNS_rr *answer__elem_ = (*answer_)[i];
			delete answer__elem_;
			answer__elem_ = 0;
		}
	}
	delete answer_;
	delete authority__elem_;
	authority__elem_ = 0;
	if (authority())
	{
		for (int i = 0; i < (int)authority()->size(); ++i)
		{
			DNS_rr *authority__elem_ = (*authority_)[i];
			delete authority__elem_;
			authority__elem_ = 0;
		}
	}
	delete authority_;
	delete additional__elem_;
	additional__elem_ = 0;
	if (additional())
	{
		for (int i = 0; i < (int)additional()->size(); ++i)
		{
			DNS_rr *additional__elem_ = (*additional_)[i];
			delete additional__elem_;
			additional__elem_ = 0;
		}
	}
	delete additional_;
}

int DNS_message::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNS *t_context)
{
	sourcedata_ = const_bytestring(t_begin_of_data, t_end_of_data);
	// Checking out-of-bound for "DNS_message:header"
	if (t_begin_of_data + (12) > t_end_of_data || t_begin_of_data + (12) < t_begin_of_data)
	{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DNS_message:header",
										  (0) + (12),
										  (t_end_of_data) - (t_begin_of_data));
	}
	// Parse "header"
	header_ = new DNS_header();
	header_->Parse(t_begin_of_data, t_end_of_data, t_context, byteorder());
	// Evaluate 'let' and 'withinput' fields

	// Parse "question"
	int t_question__arraylength;
	t_question__arraylength = 0;
	t_question__arraylength = header()->qdcount();
	if (t_question__arraylength < 0)
	{
		throw binpac::ExceptionOutOfBound("DNS_message:question",
										  t_question__arraylength, (t_end_of_data) - (t_begin_of_data));
	}
	// Check array element quantity: DNS_message:question
	if (t_begin_of_data + (t_question__arraylength) > t_end_of_data || t_begin_of_data + (t_question__arraylength) < t_begin_of_data)
		throw binpac::ExceptionOutOfBound("DNS_message:question",
										  (t_question__arraylength), (t_end_of_data) - (t_begin_of_data));
	question__elem_ = 0;
	int t_question__elem__it;
	t_question__elem__it = 0;
	int t_question__size;
	question_ = new vector<DNS_question *>;
	question_->reserve(t_question__arraylength);
	const_byteptr t_question__elem__dataptr = (t_begin_of_data + 12);
	for (; t_question__elem__it < t_question__arraylength; ++t_question__elem__it)
	{
		question__elem_ = new DNS_question(this);
		int t_question__elem__size;
		t_question__elem__size = question__elem_->Parse(t_question__elem__dataptr, t_end_of_data, t_context, byteorder());
		// Evaluate 'let' and 'withinput' fields
		question_->push_back(question__elem_);
		t_question__elem__dataptr += t_question__elem__size;
		BINPAC_ASSERT(t_question__elem__dataptr <= t_end_of_data);
		question__elem_ = 0;
	}
// end_of_question:;
	t_question__size = t_question__elem__dataptr - ((t_begin_of_data + 12));
	// Evaluate 'let' and 'withinput' fields

	const_byteptr const t_dataptr_after_question = (t_begin_of_data + 12) + (t_question__size);
	BINPAC_ASSERT(t_dataptr_after_question <= t_end_of_data);
	// Parse "answer"
	int t_answer__arraylength;
	t_answer__arraylength = 0;
	t_answer__arraylength = header()->ancount();
	if (t_answer__arraylength < 0)
	{
		throw binpac::ExceptionOutOfBound("DNS_message:answer",
										  t_answer__arraylength, (t_end_of_data) - (t_begin_of_data));
	}
	// Check array element quantity: DNS_message:answer
	if (t_begin_of_data + (t_answer__arraylength) > t_end_of_data || t_begin_of_data + (t_answer__arraylength) < t_begin_of_data)
		throw binpac::ExceptionOutOfBound("DNS_message:answer",
										  (t_answer__arraylength), (t_end_of_data) - (t_begin_of_data));
	answer__elem_ = 0;
	int t_answer__elem__it;
	t_answer__elem__it = 0;
	int t_answer__size;
	answer_ = new vector<DNS_rr *>;
	answer_->reserve(t_answer__arraylength);
	const_byteptr t_answer__elem__dataptr = t_dataptr_after_question;
	for (; t_answer__elem__it < t_answer__arraylength; ++t_answer__elem__it)
	{
		answer__elem_ = new DNS_rr(this, DNS_ANSWER);
		int t_answer__elem__size;
		t_answer__elem__size = answer__elem_->Parse(t_answer__elem__dataptr, t_end_of_data, t_context, byteorder());
		// Evaluate 'let' and 'withinput' fields
		answer_->push_back(answer__elem_);
		t_answer__elem__dataptr += t_answer__elem__size;
		BINPAC_ASSERT(t_answer__elem__dataptr <= t_end_of_data);
		answer__elem_ = 0;
	}
// end_of_answer:;
	t_answer__size = t_answer__elem__dataptr - (t_dataptr_after_question);
	// Evaluate 'let' and 'withinput' fields

	const_byteptr const t_dataptr_after_answer = t_dataptr_after_question + (t_answer__size);
	BINPAC_ASSERT(t_dataptr_after_answer <= t_end_of_data);
	// Parse "authority"
	int t_authority__arraylength;
	t_authority__arraylength = 0;
	t_authority__arraylength = header()->nscount();
	if (t_authority__arraylength < 0)
	{
		throw binpac::ExceptionOutOfBound("DNS_message:authority",
										  t_authority__arraylength, (t_end_of_data) - (t_begin_of_data));
	}
	// Check array element quantity: DNS_message:authority
	if (t_begin_of_data + (t_authority__arraylength) > t_end_of_data || t_begin_of_data + (t_authority__arraylength) < t_begin_of_data)
		throw binpac::ExceptionOutOfBound("DNS_message:authority",
										  (t_authority__arraylength), (t_end_of_data) - (t_begin_of_data));
	authority__elem_ = 0;
	int t_authority__elem__it;
	t_authority__elem__it = 0;
	int t_authority__size;
	authority_ = new vector<DNS_rr *>;
	authority_->reserve(t_authority__arraylength);
	const_byteptr t_authority__elem__dataptr = t_dataptr_after_answer;
	for (; t_authority__elem__it < t_authority__arraylength; ++t_authority__elem__it)
	{
		authority__elem_ = new DNS_rr(this, DNS_AUTHORITY);
		int t_authority__elem__size;
		t_authority__elem__size = authority__elem_->Parse(t_authority__elem__dataptr, t_end_of_data, t_context, byteorder());
		// Evaluate 'let' and 'withinput' fields
		authority_->push_back(authority__elem_);
		t_authority__elem__dataptr += t_authority__elem__size;
		BINPAC_ASSERT(t_authority__elem__dataptr <= t_end_of_data);
		authority__elem_ = 0;
	}
// end_of_authority:;
	t_authority__size = t_authority__elem__dataptr - (t_dataptr_after_answer);
	// Evaluate 'let' and 'withinput' fields

	const_byteptr const t_dataptr_after_authority = t_dataptr_after_answer + (t_authority__size);
	BINPAC_ASSERT(t_dataptr_after_authority <= t_end_of_data);
	// Parse "additional"
	int t_additional__arraylength;
	t_additional__arraylength = 0;
	t_additional__arraylength = header()->arcount();
	if (t_additional__arraylength < 0)
	{
		throw binpac::ExceptionOutOfBound("DNS_message:additional",
										  t_additional__arraylength, (t_end_of_data) - (t_begin_of_data));
	}
	// Check array element quantity: DNS_message:additional
	if (t_begin_of_data + (t_additional__arraylength) > t_end_of_data || t_begin_of_data + (t_additional__arraylength) < t_begin_of_data)
		throw binpac::ExceptionOutOfBound("DNS_message:additional",
										  (t_additional__arraylength), (t_end_of_data) - (t_begin_of_data));
	additional__elem_ = 0;
	int t_additional__elem__it;
	t_additional__elem__it = 0;
	int t_additional__size;
	additional_ = new vector<DNS_rr *>;
	additional_->reserve(t_additional__arraylength);
	const_byteptr t_additional__elem__dataptr = t_dataptr_after_authority;
	for (; t_additional__elem__it < t_additional__arraylength; ++t_additional__elem__it)
	{
		additional__elem_ = new DNS_rr(this, DNS_ADDITIONAL);
		int t_additional__elem__size;
		t_additional__elem__size = additional__elem_->Parse(t_additional__elem__dataptr, t_end_of_data, t_context, byteorder());
		// Evaluate 'let' and 'withinput' fields
		additional_->push_back(additional__elem_);
		t_additional__elem__dataptr += t_additional__elem__size;
		BINPAC_ASSERT(t_additional__elem__dataptr <= t_end_of_data);
		additional__elem_ = 0;
	}
// end_of_additional:;
	t_additional__size = t_additional__elem__dataptr - (t_dataptr_after_authority);
	// Evaluate 'let' and 'withinput' fields

	int t_DNS_message__size;
	const_byteptr const t_dataptr_after_additional = t_dataptr_after_authority + (t_additional__size);
	BINPAC_ASSERT(t_dataptr_after_additional <= t_end_of_data);
	t_DNS_message__size = t_dataptr_after_additional - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	sourcedata_.set_end(t_begin_of_data + t_DNS_message__size);
	BINPAC_ASSERT(t_begin_of_data + (t_DNS_message__size) <= t_end_of_data);
	return t_DNS_message__size;
}

DNS_header::DNS_header()
{
	id_ = 0;
	qrop_ = 0;
	qdcount_ = 0;
	ancount_ = 0;
	nscount_ = 0;
	arcount_ = 0;
	qr_ = 0;
	opcode_ = 0;
	aa_ = 0;
	tc_ = 0;
	rd_ = 0;
	ra_ = 0;
	z_ = 0;
	rcode_ = 0;
	proc_dns_header_ = 0;
}

DNS_header::~DNS_header()
{
}

int DNS_header::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNS *t_context, int t_byteorder)
{
	// Checking out-of-bound for "DNS_header"
	if (t_begin_of_data + (12) > t_end_of_data || t_begin_of_data + (12) < t_begin_of_data)
	{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DNS_header",
										  (0) + (12),
										  (t_end_of_data) - (t_begin_of_data));
	}
	// Parse "id"
	id_ = FixByteOrder(t_byteorder, *((uint16 const *)(t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields

	// Parse "qrop"
	qrop_ = FixByteOrder(t_byteorder, *((uint16 const *)((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields

	// Parse "qdcount"
	qdcount_ = FixByteOrder(t_byteorder, *((uint16 const *)((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields

	// Parse "ancount"
	ancount_ = FixByteOrder(t_byteorder, *((uint16 const *)((t_begin_of_data + 6))));
	// Evaluate 'let' and 'withinput' fields

	// Parse "nscount"
	nscount_ = FixByteOrder(t_byteorder, *((uint16 const *)((t_begin_of_data + 8))));
	// Evaluate 'let' and 'withinput' fields

	// Parse "arcount"
	arcount_ = FixByteOrder(t_byteorder, *((uint16 const *)((t_begin_of_data + 10))));
	// Evaluate 'let' and 'withinput' fields

	// Evaluate 'let' and 'withinput' fields
	qr_ = qrop() >> 15;
	opcode_ = (qrop() >> 11) & 0xf;
	aa_ = (qrop() >> 10) & 0x1;
	tc_ = (qrop() >> 9) & 0x1;
	rd_ = (qrop() >> 8) & 0x1;
	ra_ = (qrop() >> 7) & 0x1;
	z_ = (qrop() >> 4) & 0x7;
	rcode_ = qrop() & 0xf;
	proc_dns_header_ = t_context->flow()->process_dns_header(this);
	BINPAC_ASSERT(t_begin_of_data + (12) <= t_end_of_data);
	return 12;
}

DNS_question::DNS_question(DNS_message *msg)
{
	qname_ = 0;
	qtype_ = 0;
	qclass_ = 0;
	msg_ = msg;
	proc_dns_question_ = 0;
}

DNS_question::~DNS_question()
{
	delete qname_;
	qname_ = 0;
}

int DNS_question::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNS *t_context, int t_byteorder)
{
	// Parse "qname"
	qname_ = new DNS_name(msg());
	int t_qname__size;
	t_qname__size = qname_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields

	const_byteptr const t_dataptr_after_qname = t_begin_of_data + (t_qname__size);
	BINPAC_ASSERT(t_dataptr_after_qname <= t_end_of_data);
	// Checking out-of-bound for "DNS_question:qclass"
	if ((t_dataptr_after_qname + 2) + (2) > t_end_of_data || (t_dataptr_after_qname + 2) + (2) < (t_dataptr_after_qname + 2))
	{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DNS_question:qclass",
										  (((t_dataptr_after_qname + 2) - t_begin_of_data)) + (2),
										  (t_end_of_data) - (t_begin_of_data));
	}
	// Parse "qtype"
	qtype_ = FixByteOrder(t_byteorder, *((uint16 const *)(t_dataptr_after_qname)));
	// Evaluate 'let' and 'withinput' fields

	// Parse "qclass"
	qclass_ = FixByteOrder(t_byteorder, *((uint16 const *)((t_dataptr_after_qname + 2))));
	// Evaluate 'let' and 'withinput' fields

	int t_DNS_question__size;
	t_DNS_question__size = (t_dataptr_after_qname + 4) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_dns_question_ = t_context->flow()->process_dns_question(this);
	BINPAC_ASSERT(t_begin_of_data + (t_DNS_question__size) <= t_end_of_data);
	return t_DNS_question__size;
}

DNS_name::DNS_name(DNS_message *msg)
{
	labels_ = 0;
	labels__elem_ = 0;
	msg_ = msg;
}

DNS_name::~DNS_name()
{
	delete labels__elem_;
	labels__elem_ = 0;
	if (labels())
	{
		for (int i = 0; i < (int)labels()->size(); ++i)
		{
			DNS_label *labels__elem_ = (*labels_)[i];
			delete labels__elem_;
			labels__elem_ = 0;
		}
	}
	delete labels_;
}

int DNS_name::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNS *t_context)
{
	// Parse "labels"
	int t_labels__arraylength;
	t_labels__arraylength = 0;
	labels__elem_ = 0;
	int t_labels__elem__it;
	t_labels__elem__it = 0;
	int t_labels__size;
	labels_ = new vector<DNS_label *>;
	const_byteptr t_labels__elem__dataptr = t_begin_of_data;

	UNUSED(t_labels__arraylength);
	for (; /* forever */; ++t_labels__elem__it)
	{
		// Check &until(labels__elem__dataptr >= end_of_data)
		if (t_labels__elem__dataptr >= t_end_of_data)
		{
			labels__elem_ = 0;
			goto end_of_labels;
		}
		labels__elem_ = new DNS_label(msg());
		int t_labels__elem__size;
		t_labels__elem__size = labels__elem_->Parse(t_labels__elem__dataptr, t_end_of_data, t_context);
		// Evaluate 'let' and 'withinput' fields
		labels_->push_back(labels__elem_);
		t_labels__elem__dataptr += t_labels__elem__size;
		BINPAC_ASSERT(t_labels__elem__dataptr <= t_end_of_data);
		// Check &until( ( @$element->last@ ) )
		if ((labels__elem_->last()))
		{
			labels__elem_ = 0;
			goto end_of_labels;
		}
		labels__elem_ = 0;
	}
end_of_labels:;
	t_labels__size = t_labels__elem__dataptr - (t_begin_of_data);
	// Evaluate 'let' and 'withinput' fields

	int t_DNS_name__size;
	const_byteptr const t_dataptr_after_labels = t_begin_of_data + (t_labels__size);
	BINPAC_ASSERT(t_dataptr_after_labels <= t_end_of_data);
	t_DNS_name__size = t_dataptr_after_labels - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_DNS_name__size) <= t_end_of_data);
	return t_DNS_name__size;
}

DNS_label::DNS_label(DNS_message *msg)
{
	length_ = 0;
	data_case_index_ = -1;
	ptr_lo_ = 0;
	msg_ = msg;
	label_type_ = 0;
	last_ = 0;
	ptr_ = 0;
	has_ptr_ = 0;
	clear_pointer_set_ = 0;
	has_clear_pointer_set_ = 0;
}

DNS_label::~DNS_label()
{
	switch (data_case_index())
	{
	case 0:
		// Clean up "label"
		{
			label_.free();
		}
		break;
	case 3:
		// Clean up "ptr_lo"
		{
		}
		break;
	}
	delete ptr_;
	ptr_ = 0;
}

int DNS_label::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNS *t_context)
{
	// Checking out-of-bound for "DNS_label:length"
	if (t_begin_of_data + (1) > t_end_of_data || t_begin_of_data + (1) < t_begin_of_data)
	{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DNS_label:length",
										  (0) + (1),
										  (t_end_of_data) - (t_begin_of_data));
	}
	// Parse "length"
	length_ = *((uint8 const *)(t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields

	// Parse "data"
	int t_data__size;
	label_type_ = length() >> 6;
	data_case_index_ = label_type();
	switch (data_case_index())
	{
	case 0:
		// Parse "label"
		{
			int t_label__size;
			t_label__size = length();
			// Checking out-of-bound for "DNS_label:label"
			if ((t_begin_of_data + 1) + (t_label__size) > t_end_of_data || (t_begin_of_data + 1) + (t_label__size) < (t_begin_of_data + 1))
			{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("DNS_label:label",
												  (1) + (t_label__size),
												  (t_end_of_data) - (t_begin_of_data));
			}
			{
				// Setting t_end_of_data with &length
				const_byteptr t_end_of_data = (t_begin_of_data + 1) + t_label__size;
				UNUSED(t_end_of_data);
				int t_label_string_length;
				t_label_string_length = length();
				// check for negative sizes
				if (t_label_string_length < 0)
					throw binpac::ExceptionInvalidStringLength("./dns-protocol.pac:115", t_label_string_length);
				label_.init((t_begin_of_data + 1), t_label_string_length);
				// Evaluate 'let' and 'withinput' fields
			}
			t_data__size = t_label__size;
		}
		break;
	case 3:
		// Parse "ptr_lo"
		{
			// Checking out-of-bound for "DNS_label:ptr_lo"
			if ((t_begin_of_data + 1) + (1) > t_end_of_data || (t_begin_of_data + 1) + (1) < (t_begin_of_data + 1))
			{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("DNS_label:ptr_lo",
												  (1) + (1),
												  (t_end_of_data) - (t_begin_of_data));
			}
			ptr_lo_ = *((uint8 const *)((t_begin_of_data + 1)));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 1;
		}
		break;
	default:
		throw binpac::ExceptionInvalidCaseIndex("DNS_label", data_case_index());
		break;
	}
	// Evaluate 'let' and 'withinput' fields

	int t_DNS_label__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 1) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_DNS_label__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	last_ = (length() == 0) || (label_type() == 3);
	// Parse "ptr"
	has_ptr_ = (label_type() == 3);
	if (has_ptr())
	{
		ptr_ = new DNS_name(msg());
		const_byteptr t_begin_of_data, t_end_of_data;
		get_pointers(t_context->flow()->get_pointer(msg()->sourcedata(), ((length() & 0x3f) << 8) | ptr_lo()), &t_begin_of_data, &t_end_of_data);
		int t_ptr__size;
		t_ptr__size = ptr_->Parse(t_begin_of_data, t_end_of_data, t_context);
		UNUSED(t_ptr__size);
		// Evaluate 'let' and 'withinput' fields
	}
	has_clear_pointer_set_ = (last());
	if (has_clear_pointer_set())
	{
		clear_pointer_set_ = t_context->flow()->reset_pointer_set();
	}
	BINPAC_ASSERT(t_begin_of_data + (t_DNS_label__size) <= t_end_of_data);
	return t_DNS_label__size;
}

DNS_rr::DNS_rr(DNS_message *msg, DNS_answer_type answer_type)
{
	rr_name_ = 0;
	rr_type_ = 0;
	rr_class_ = 0;
	rr_ttl_ = 0;
	rr_rdlength_ = 0;
	rr_rdata_ = 0;
	msg_ = msg;
	answer_type_ = answer_type;
	proc_dns_rr_ = 0;
}

DNS_rr::~DNS_rr()
{
	delete rr_name_;
	rr_name_ = 0;
	delete rr_rdata_;
	rr_rdata_ = 0;
}

int DNS_rr::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNS *t_context, int t_byteorder)
{
	// Parse "rr_name"
	rr_name_ = new DNS_name(msg());
	int t_rr_name__size;
	t_rr_name__size = rr_name_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields

	const_byteptr const t_dataptr_after_rr_name = t_begin_of_data + (t_rr_name__size);
	BINPAC_ASSERT(t_dataptr_after_rr_name <= t_end_of_data);
	// Checking out-of-bound for "DNS_rr:rr_rdlength"
	if ((t_dataptr_after_rr_name + 8) + (2) > t_end_of_data || (t_dataptr_after_rr_name + 8) + (2) < (t_dataptr_after_rr_name + 8))
	{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DNS_rr:rr_rdlength",
										  (((t_dataptr_after_rr_name + 8) - t_begin_of_data)) + (2),
										  (t_end_of_data) - (t_begin_of_data));
	}
	// Parse "rr_type"
	rr_type_ = FixByteOrder(t_byteorder, *((uint16 const *)(t_dataptr_after_rr_name)));
	// Evaluate 'let' and 'withinput' fields

	// Parse "rr_class"
	rr_class_ = FixByteOrder(t_byteorder, *((uint16 const *)((t_dataptr_after_rr_name + 2))));
	// Evaluate 'let' and 'withinput' fields

	// Parse "rr_ttl"
	rr_ttl_ = FixByteOrder(t_byteorder, *((uint32 const *)((t_dataptr_after_rr_name + 4))));
	// Evaluate 'let' and 'withinput' fields

	// Parse "rr_rdlength"
	rr_rdlength_ = FixByteOrder(t_byteorder, *((uint16 const *)((t_dataptr_after_rr_name + 8))));
	// Evaluate 'let' and 'withinput' fields

	// Parse "rr_rdata"
	rr_rdata_ = new DNS_rdata(msg(), rr_type(), rr_class());
	int t_rr_rdata__size;
	t_rr_rdata__size = rr_rdlength();
	// Checking out-of-bound for "DNS_rr:rr_rdata"
	if ((t_dataptr_after_rr_name + 10) + (t_rr_rdata__size) > t_end_of_data || (t_dataptr_after_rr_name + 10) + (t_rr_rdata__size) < (t_dataptr_after_rr_name + 10))
	{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DNS_rr:rr_rdata",
										  (((t_dataptr_after_rr_name + 10) - t_begin_of_data)) + (t_rr_rdata__size),
										  (t_end_of_data) - (t_begin_of_data));
	}
	{
		// Setting t_end_of_data with &length
		const_byteptr t_end_of_data = (t_dataptr_after_rr_name + 10) + t_rr_rdata__size;
		rr_rdata_->Parse((t_dataptr_after_rr_name + 10), t_end_of_data, t_context, t_byteorder);
		// Evaluate 'let' and 'withinput' fields
	}

	int t_DNS_rr__size;
	const_byteptr const t_dataptr_after_rr_rdata = (t_dataptr_after_rr_name + 10) + (t_rr_rdata__size);
	BINPAC_ASSERT(t_dataptr_after_rr_rdata <= t_end_of_data);
	t_DNS_rr__size = t_dataptr_after_rr_rdata - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	proc_dns_rr_ = t_context->flow()->process_dns_rr(this);
	BINPAC_ASSERT(t_begin_of_data + (t_DNS_rr__size) <= t_end_of_data);
	return t_DNS_rr__size;
}

DNS_rdata::DNS_rdata(DNS_message *msg, uint16 rr_type, uint16 rr_class)
{
	val_case_index_ = -1;
	type_a_ = 0;
	type_ns_ = 0;
	type_cname_ = 0;
	type_soa_ = 0;
	type_ptr_ = 0;
	type_mx_ = 0;
	type_aaaa_ = 0;
	type_aaaa__elem_ = 0;
	type_wks_ = 0;
	type_hinfo_ = 0;
	msg_ = msg;
	rr_type_ = rr_type;
	rr_class_ = rr_class;
}

DNS_rdata::~DNS_rdata()
{
	switch (val_case_index())
	{
	case 1:
		// Clean up "type_a"
		{
		}
		break;
	case 2:
		// Clean up "type_ns"
		{
			delete type_ns_;
			type_ns_ = 0;
		}
		break;
	case 5:
		// Clean up "type_cname"
		{
			delete type_cname_;
			type_cname_ = 0;
		}
		break;
	case 6:
		// Clean up "type_soa"
		{
			delete type_soa_;
			type_soa_ = 0;
		}
		break;
	case 12:
		// Clean up "type_ptr"
		{
			delete type_ptr_;
			type_ptr_ = 0;
		}
		break;
	case 15:
		// Clean up "type_mx"
		{
			delete type_mx_;
			type_mx_ = 0;
		}
		break;
	case 28:
	case 38:
		// Clean up "type_aaaa"
		{
			delete type_aaaa_;
		}
		break;
	case 11:
		// Clean up "type_wks"
		{
			delete type_wks_;
			type_wks_ = 0;
		}
		break;
	case 13:
		// Clean up "type_hinfo"
		{
			delete type_hinfo_;
			type_hinfo_ = 0;
		}
		break;
	case 16:
		// Clean up "type_txt"
		{
			type_txt_.free();
		}
		break;
	default:
		// Clean up "unknown"
		{
			unknown_.free();
		}
		break;
	}
}

int DNS_rdata::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNS *t_context, int t_byteorder)
{
	int t_val__size;
	val_case_index_ = rr_type();
	switch (val_case_index())
	{
	case 1:
		// Parse "type_a"
		{
			// Checking out-of-bound for "DNS_rdata:type_a"
			if (t_begin_of_data + (4) > t_end_of_data || t_begin_of_data + (4) < t_begin_of_data)
			{
				// Handle out-of-bound condition
				throw binpac::ExceptionOutOfBound("DNS_rdata:type_a",
												  (0) + (4),
												  (t_end_of_data) - (t_begin_of_data));
			}
			type_a_ = FixByteOrder(t_byteorder, *((uint32 const *)(t_begin_of_data)));
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 4;
		}
		break;
	case 2:
		// Parse "type_ns"
		{
			type_ns_ = new DNS_name(msg());
			int t_type_ns__size;
			t_type_ns__size = type_ns_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_type_ns__size;
		}
		break;
	case 5:
		// Parse "type_cname"
		{
			type_cname_ = new DNS_name(msg());
			int t_type_cname__size;
			t_type_cname__size = type_cname_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_type_cname__size;
		}
		break;
	case 6:
		// Parse "type_soa"
		{
			type_soa_ = new DNS_rdata_SOA(msg());
			int t_type_soa__size;
			t_type_soa__size = type_soa_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_type_soa__size;
		}
		break;
	case 12:
		// Parse "type_ptr"
		{
			type_ptr_ = new DNS_name(msg());
			int t_type_ptr__size;
			t_type_ptr__size = type_ptr_->Parse(t_begin_of_data, t_end_of_data, t_context);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_type_ptr__size;
		}
		break;
	case 15:
		// Parse "type_mx"
		{
			type_mx_ = new DNS_rdata_MX(msg());
			int t_type_mx__size;
			t_type_mx__size = type_mx_->Parse(t_begin_of_data, t_end_of_data, t_context, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_type_mx__size;
		}
		break;
	case 28:
	case 38:
		// Parse "type_aaaa"
		{
			int t_type_aaaa__arraylength;
			t_type_aaaa__arraylength = 0;
			t_type_aaaa__arraylength = 4;
			if (t_type_aaaa__arraylength < 0)
			{
				throw binpac::ExceptionOutOfBound("DNS_rdata:type_aaaa",
												  t_type_aaaa__arraylength, (t_end_of_data) - (t_begin_of_data));
			}
			// Check bounds for static-size array: DNS_rdata:type_aaaa
			if (t_begin_of_data + ((4) * (t_type_aaaa__arraylength)) > t_end_of_data || t_begin_of_data + ((4) * (t_type_aaaa__arraylength)) < t_begin_of_data)
				throw binpac::ExceptionOutOfBound("DNS_rdata:type_aaaa",
												  ((4) * (t_type_aaaa__arraylength)), (t_end_of_data) - (t_begin_of_data));
			type_aaaa__elem_ = 0;
			int t_type_aaaa__elem__it;
			t_type_aaaa__elem__it = 0;
			type_aaaa_ = new vector<uint32>;
			type_aaaa_->reserve(t_type_aaaa__arraylength);
			const_byteptr t_type_aaaa__elem__dataptr = t_begin_of_data;
			for (; t_type_aaaa__elem__it < t_type_aaaa__arraylength; ++t_type_aaaa__elem__it)
			{
				type_aaaa__elem_ = FixByteOrder(t_byteorder, *((uint32 const *)(t_type_aaaa__elem__dataptr)));
				// Evaluate 'let' and 'withinput' fields
				type_aaaa_->push_back(type_aaaa__elem_);
				t_type_aaaa__elem__dataptr += 4;
				BINPAC_ASSERT(t_type_aaaa__elem__dataptr <= t_end_of_data);
			}
		// end_of_type_aaaa:;
			// Evaluate 'let' and 'withinput' fields
			t_val__size = 16;
		}
		break;
	case 11:
		// Parse "type_wks"
		{
			type_wks_ = new DNS_rdata_WKS();
			int t_type_wks__size;
			t_type_wks__size = type_wks_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_type_wks__size;
		}
		break;
	case 13:
		// Parse "type_hinfo"
		{
			type_hinfo_ = new DNS_rdata_HINFO();
			int t_type_hinfo__size;
			t_type_hinfo__size = type_hinfo_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_type_hinfo__size;
		}
		break;
	case 16:
		// Parse "type_txt"
		{
			int t_type_txt_string_length;
			t_type_txt_string_length = (t_end_of_data) - (t_begin_of_data);
			int t_type_txt__size;
			t_type_txt__size = t_type_txt_string_length;
			// check for negative sizes
			if (t_type_txt_string_length < 0)
				throw binpac::ExceptionInvalidStringLength("./dns-protocol.pac:177", t_type_txt_string_length);
			type_txt_.init(t_begin_of_data, t_type_txt_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_type_txt__size;
		}
		break;
	default:
		// Parse "unknown"
		{
			int t_unknown_string_length;
			t_unknown_string_length = (t_end_of_data) - (t_begin_of_data);
			int t_unknown__size;
			t_unknown__size = t_unknown_string_length;
			// check for negative sizes
			if (t_unknown_string_length < 0)
				throw binpac::ExceptionInvalidStringLength("./dns-protocol.pac:188", t_unknown_string_length);
			unknown_.init(t_begin_of_data, t_unknown_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_unknown__size;
		}
		break;
	}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
}

DNS_char_string::DNS_char_string()
{
	length_ = 0;
}

DNS_char_string::~DNS_char_string()
{
	data_.free();
}

int DNS_char_string::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
{
	// Checking out-of-bound for "DNS_char_string:length"
	if (t_begin_of_data + (1) > t_end_of_data || t_begin_of_data + (1) < t_begin_of_data)
	{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DNS_char_string:length",
										  (0) + (1),
										  (t_end_of_data) - (t_begin_of_data));
	}
	// Parse "length"
	length_ = *((uint8 const *)(t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields

	// Parse "data"
	int t_data__size;
	t_data__size = length();
	// Checking out-of-bound for "DNS_char_string:data"
	if ((t_begin_of_data + 1) + (t_data__size) > t_end_of_data || (t_begin_of_data + 1) + (t_data__size) < (t_begin_of_data + 1))
	{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DNS_char_string:data",
										  (1) + (t_data__size),
										  (t_end_of_data) - (t_begin_of_data));
	}
	{
		// Setting t_end_of_data with &length
		const_byteptr t_end_of_data = (t_begin_of_data + 1) + t_data__size;
		UNUSED(t_end_of_data);
		int t_data_string_length;
		t_data_string_length = length();
		// check for negative sizes
		if (t_data_string_length < 0)
			throw binpac::ExceptionInvalidStringLength("./dns-protocol.pac:193", t_data_string_length);
		data_.init((t_begin_of_data + 1), t_data_string_length);
		// Evaluate 'let' and 'withinput' fields
	}

	int t_DNS_char_string__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 1) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_DNS_char_string__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_DNS_char_string__size) <= t_end_of_data);
	return t_DNS_char_string__size;
}

DNS_rdata_MX::DNS_rdata_MX(DNS_message *msg)
{
	preference_ = 0;
	name_ = 0;
	msg_ = msg;
}

DNS_rdata_MX::~DNS_rdata_MX()
{
	delete name_;
	name_ = 0;
}

int DNS_rdata_MX::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNS *t_context, int t_byteorder)
{
	// Checking out-of-bound for "DNS_rdata_MX:preference"
	if (t_begin_of_data + (2) > t_end_of_data || t_begin_of_data + (2) < t_begin_of_data)
	{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DNS_rdata_MX:preference",
										  (0) + (2),
										  (t_end_of_data) - (t_begin_of_data));
	}
	// Parse "preference"
	preference_ = FixByteOrder(t_byteorder, *((uint16 const *)(t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields

	// Parse "name"
	name_ = new DNS_name(msg());
	int t_name__size;
	t_name__size = name_->Parse((t_begin_of_data + 2), t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields

	int t_DNS_rdata_MX__size;
	const_byteptr const t_dataptr_after_name = (t_begin_of_data + 2) + (t_name__size);
	BINPAC_ASSERT(t_dataptr_after_name <= t_end_of_data);
	t_DNS_rdata_MX__size = t_dataptr_after_name - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_DNS_rdata_MX__size) <= t_end_of_data);
	return t_DNS_rdata_MX__size;
}

DNS_rdata_SOA::DNS_rdata_SOA(DNS_message *msg)
{
	mname_ = 0;
	rname_ = 0;
	serial_ = 0;
	refresh_ = 0;
	retry_ = 0;
	expire_ = 0;
	minimum_ = 0;
	msg_ = msg;
}

DNS_rdata_SOA::~DNS_rdata_SOA()
{
	delete mname_;
	mname_ = 0;
	delete rname_;
	rname_ = 0;
}

int DNS_rdata_SOA::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, ContextDNS *t_context, int t_byteorder)
{
	// Parse "mname"
	mname_ = new DNS_name(msg());
	int t_mname__size;
	t_mname__size = mname_->Parse(t_begin_of_data, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields

	const_byteptr const t_dataptr_after_mname = t_begin_of_data + (t_mname__size);
	BINPAC_ASSERT(t_dataptr_after_mname <= t_end_of_data);
	// Parse "rname"
	rname_ = new DNS_name(msg());
	int t_rname__size;
	t_rname__size = rname_->Parse(t_dataptr_after_mname, t_end_of_data, t_context);
	// Evaluate 'let' and 'withinput' fields

	const_byteptr const t_dataptr_after_rname = t_dataptr_after_mname + (t_rname__size);
	BINPAC_ASSERT(t_dataptr_after_rname <= t_end_of_data);
	// Checking out-of-bound for "DNS_rdata_SOA:minimum"
	if ((t_dataptr_after_rname + 16) + (4) > t_end_of_data || (t_dataptr_after_rname + 16) + (4) < (t_dataptr_after_rname + 16))
	{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DNS_rdata_SOA:minimum",
										  (((t_dataptr_after_rname + 16) - t_begin_of_data)) + (4),
										  (t_end_of_data) - (t_begin_of_data));
	}
	// Parse "serial"
	serial_ = FixByteOrder(t_byteorder, *((uint32 const *)(t_dataptr_after_rname)));
	// Evaluate 'let' and 'withinput' fields

	// Parse "refresh"
	refresh_ = FixByteOrder(t_byteorder, *((uint32 const *)((t_dataptr_after_rname + 4))));
	// Evaluate 'let' and 'withinput' fields

	// Parse "retry"
	retry_ = FixByteOrder(t_byteorder, *((uint32 const *)((t_dataptr_after_rname + 8))));
	// Evaluate 'let' and 'withinput' fields

	// Parse "expire"
	expire_ = FixByteOrder(t_byteorder, *((uint32 const *)((t_dataptr_after_rname + 12))));
	// Evaluate 'let' and 'withinput' fields

	// Parse "minimum"
	minimum_ = FixByteOrder(t_byteorder, *((uint32 const *)((t_dataptr_after_rname + 16))));
	// Evaluate 'let' and 'withinput' fields

	int t_DNS_rdata_SOA__size;
	t_DNS_rdata_SOA__size = (t_dataptr_after_rname + 20) - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_DNS_rdata_SOA__size) <= t_end_of_data);
	return t_DNS_rdata_SOA__size;
}

DNS_rdata_WKS::DNS_rdata_WKS()
{
	address_ = 0;
	protocol_ = 0;
}

DNS_rdata_WKS::~DNS_rdata_WKS()
{
	bitmap_.free();
}

int DNS_rdata_WKS::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
{
	// Checking out-of-bound for "DNS_rdata_WKS:protocol"
	if ((t_begin_of_data + 4) + (1) > t_end_of_data || (t_begin_of_data + 4) + (1) < (t_begin_of_data + 4))
	{
		// Handle out-of-bound condition
		throw binpac::ExceptionOutOfBound("DNS_rdata_WKS:protocol",
										  (4) + (1),
										  (t_end_of_data) - (t_begin_of_data));
	}
	// Parse "address"
	address_ = FixByteOrder(t_byteorder, *((uint32 const *)(t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields

	// Parse "protocol"
	protocol_ = *((uint8 const *)((t_begin_of_data + 4)));
	// Evaluate 'let' and 'withinput' fields

	// Parse "bitmap"
	int t_bitmap_string_length;
	t_bitmap_string_length = (t_end_of_data) - ((t_begin_of_data + 5));
	int t_bitmap__size;
	t_bitmap__size = t_bitmap_string_length;
	// check for negative sizes
	if (t_bitmap_string_length < 0)
		throw binpac::ExceptionInvalidStringLength("./dns-protocol.pac:214", t_bitmap_string_length);
	bitmap_.init((t_begin_of_data + 5), t_bitmap_string_length);
	// Evaluate 'let' and 'withinput' fields

	int t_DNS_rdata_WKS__size;
	const_byteptr const t_dataptr_after_bitmap = (t_begin_of_data + 5) + (t_bitmap__size);
	BINPAC_ASSERT(t_dataptr_after_bitmap <= t_end_of_data);
	t_DNS_rdata_WKS__size = t_dataptr_after_bitmap - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_DNS_rdata_WKS__size) <= t_end_of_data);
	return t_DNS_rdata_WKS__size;
}

DNS_rdata_HINFO::DNS_rdata_HINFO()
{
	cpu_ = 0;
	os_ = 0;
}

DNS_rdata_HINFO::~DNS_rdata_HINFO()
{
	delete cpu_;
	cpu_ = 0;
	delete os_;
	os_ = 0;
}

int DNS_rdata_HINFO::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
{
	// Parse "cpu"
	cpu_ = new DNS_char_string();
	int t_cpu__size;
	t_cpu__size = cpu_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields

	const_byteptr const t_dataptr_after_cpu = t_begin_of_data + (t_cpu__size);
	BINPAC_ASSERT(t_dataptr_after_cpu <= t_end_of_data);
	// Parse "os"
	os_ = new DNS_char_string();
	int t_os__size;
	t_os__size = os_->Parse(t_dataptr_after_cpu, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields

	int t_DNS_rdata_HINFO__size;
	const_byteptr const t_dataptr_after_os = t_dataptr_after_cpu + (t_os__size);
	BINPAC_ASSERT(t_dataptr_after_os <= t_end_of_data);
	t_DNS_rdata_HINFO__size = t_dataptr_after_os - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_DNS_rdata_HINFO__size) <= t_end_of_data);
	return t_DNS_rdata_HINFO__size;
}

int add_to_name_buffer(DNS_name *name, char *buf, const int buf_n, int buf_i)
{
	for (int i = 0; i < int(name->labels()->size()); ++i)
	{
		DNS_label *label = (*name->labels())[i];
		if (label->label_type() == 0)
		{
			bytestring const &label_str = label->label();
			if (buf_i > 0 && buf_i < buf_n)
				buf[buf_i++] = '.';
			BINPAC_ASSERT(buf_i + label_str.length() <= buf_n);
			memcpy(buf + buf_i, label_str.begin(),
				   label_str.length());
			buf_i += label_str.length();
		}
		else if (label->label_type() == 3)
		{
			return add_to_name_buffer(label->ptr(), buf,
									  buf_n, buf_i);
		}
	}

	return buf_i;
}

DNS_Flow::DNS_Flow(DNS_Conn *connection, bool is_orig)
{
	connection_ = connection;
	is_orig_ = is_orig;
	dataunit_ = 0;
	context_ = 0;
}

DNS_Flow::~DNS_Flow()
{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
}

void DNS_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
{
	try
	{
		dataunit_ = new DNS_PDU(is_orig());
		context_ = new ContextDNS(connection(), this);
		int t_dataunit__size;
		t_dataunit__size = dataunit_->Parse(t_begin_of_data, t_end_of_data, context_);
		// Evaluate 'let' and 'withinput' fields
		UNUSED(t_dataunit__size);
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
	}
	catch (binpac::Exception const &e)
	{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		throw;
	}
}

void DNS_Flow::NewGap(int gap_length)
{
	UNUSED(gap_length);
}

void DNS_Flow::FlowEOF()
{
}

const_bytestring DNS_Flow::get_pointer(const_bytestring const &msgdata, int offset)
{

	if (offset < 0 || offset >= msgdata.length())
		return const_bytestring(0, 0);

	if (pointer_set.find(offset) != pointer_set.end())
		throw Exception("DNS pointer loop!");

	pointer_set.insert(offset);
	return const_bytestring(msgdata.begin() + offset, msgdata.end());
}

bool DNS_Flow::reset_pointer_set()
{

	pointer_set.clear();
	return true;
}

bool DNS_Flow::process_dns_header(DNS_header *hdr)
{

	DNS_header *header = hdr;
	UNUSED(header);
	connection()->info()->dh_ancount = hdr->ancount();
	return true;
}

bool DNS_Flow::process_dns_question(DNS_question *question)
{

	DNS_message *msg = question->msg();
	UNUSED(msg);
	click_dns_info *info = connection()->info();
	char name_buf[520];

	int n = add_to_name_buffer(question->qname(), name_buf, sizeof(name_buf), 0);
	if (n > 0)
	{
		--n;
	}
	BINPAC_ASSERT(n < int(sizeof(name_buf)));
	name_buf[n] = '\0';

	info->qname = new char[n];
	memcpy(info->qname, name_buf, n);
	info->dns_type = question->qtype();
	info->dns_class = question->qclass();

	LOG_DEBUG("DNS QNAME: %s", info->qname);
	LOG_DEBUG("DNS Type: %d\n", info->dns_type);
	LOG_DEBUG("DNS Class: %d\n", info->dns_class);
	return true;
}

bool DNS_Flow::process_dns_rr(DNS_rr *rr)
{

	const DNS_rdata *rd = rr->rr_rdata();

	switch (rr->rr_type())
	{
	case TYPE_A:
		if (rr->answer_type() == DNS_ANSWER)
		{
			uint32 addr = rd->type_a();
			connection()->info()->dns_record_ip = addr;
			_print_in_addr(connection()->info()->dns_record_ip);
		}
		break;

	case TYPE_A6:
		break;

	case TYPE_AAAA:
		break;

	case TYPE_NS:
		break;

	case TYPE_CNAME:
		break;

	case TYPE_SOA:
		break;

	case TYPE_PTR:
		break;

	case TYPE_MX:
		break;

	case TYPE_EDNS:
		break;
	}

	return true;
}

} // namespace DNS
} // namespace binpac

/* @end */
